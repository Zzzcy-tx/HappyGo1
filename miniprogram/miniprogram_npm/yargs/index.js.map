{"version":3,"sources":["index.js","yargs.js","build/lib/yargs.js","build/lib/command.js","build/lib/common-types.js","build/lib/is-promise.js","build/lib/middleware.js","build/lib/argsert.js","build/lib/yerror.js","build/lib/parse-command.js","build/lib/usage.js","build/lib/obj-filter.js","build/lib/completion.js","build/lib/completion-templates.js","build/lib/validation.js","build/lib/levenshtein.js","build/lib/apply-extends.js","build/lib/process-argv.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;AELA,ADGA,AFMA,ACHA;AELA,ADGA,AFMA,ACHA;AELA,ADGA,AFMA,ACHA;AELA,ACHA,AFMA,AFMA,ACHA;AELA,ACHA,AFMA,AFMA,ACHA;AELA,ACHA,AFMA,AFMA,ACHA;AELA,ACHA,ACHA,AHSA,AFMA,ACHA;AELA,ACHA,ACHA,AHSA,AFMA,ACHA;AELA,ACHA,ACHA,AHSA,AFMA,ACHA;AELA,ACHA,ACHA,ACHA,AJYA,AFMA;AGRA,ACHA,ACHA,ACHA,AJYA,AFMA;AGRA,ACHA,ACHA,ACHA,AJYA,AFMA;AOpBA,AJYA,ACHA,ACHA,ACHA,AJYA,AFMA;AOpBA,AJYA,ACHA,ACHA,ACHA,AJYA,AFMA;AOpBA,AJYA,ACHA,ACHA,ACHA,AJYA,AFMA;AOpBA,AJYA,ACHA,ACHA,ACHA,AJYA,AMlBA,ARwBA;AOpBA,AJYA,ACHA,AENA,AJYA,AMlBA,ARwBA;AOpBA,AJYA,ACHA,AENA,AJYA,AMlBA,ARwBA;AOpBA,AJYA,ACHA,AENA,AGTA,APqBA,AMlBA,ARwBA;AOpBA,AJYA,ACHA,AENA,AGTA,APqBA,AMlBA,ARwBA;AOpBA,AJYA,ACHA,AENA,AGTA,APqBA,AMlBA,ARwBA;AOpBA,AJYA,ACHA,AENA,AGTA,ACHA,ARwBA,AMlBA,ARwBA;AOpBA,AJYA,ACHA,AENA,AGTA,ACHA,ARwBA,AMlBA,ARwBA;AOpBA,AJYA,ACHA,AENA,AGTA,ACHA,ARwBA,AMlBA,ARwBA;AOpBA,AJYA,ACHA,AENA,AKfA,AFMA,ACHA,ARwBA,AMlBA,ARwBA;AOpBA,AJYA,ACHA,AENA,AKfA,AFMA,ACHA,ARwBA,AMlBA,ARwBA;AOpBA,AJYA,ACHA,AENA,AKfA,AFMA,ACHA,ARwBA,AMlBA,ARwBA;AOpBA,AJYA,ACHA,AQxBA,ANkBA,AKfA,AFMA,ACHA,ARwBA,AFMA;AOpBA,AJYA,ACHA,AQxBA,ANkBA,AKfA,AFMA,ACHA,ARwBA,AFMA;AOpBA,AJYA,AS3BA,ANkBA,AKfA,AFMA,ACHA,ARwBA,AFMA;AOpBA,AJYA,AU9BA,ADGA,ANkBA,AKfA,AFMA,ACHA,ARwBA,AFMA;AOpBA,AJYA,AU9BA,ADGA,ANkBA,AKfA,AFMA,ACHA,ARwBA,AFMA;AOpBA,AJYA,AU9BA,ADGA,ANkBA,AKfA,AFMA,ACHA,ARwBA;AKdA,AJYA,AU9BA,ADGA,ANkBA,AKfA,AFMA,ACHA,AIZA,AZoCA;AKdA,AJYA,AU9BA,ADGA,ANkBA,AKfA,AFMA,ACHA,AIZA,AZoCA;AKdA,AJYA,AU9BA,ADGA,ANkBA,AKfA,AFMA,ACHA,AIZA,AZoCA;AKdA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AKfA,AFMA,ACHA,AIZA,AZoCA;AKdA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AKfA,AFMA,ACHA,AIZA,AZoCA;AKdA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AKfA,AFMA,ACHA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AGTA,ACHA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AGTA,ACHA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AGTA,ACHA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AGTA,AQxBA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AGTA,AQxBA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AGTA,AQxBA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AGTA,AQxBA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AGTA,AQxBA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AGTA,AQxBA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AGTA,AQxBA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AGTA,AQxBA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AGTA,AQxBA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AGTA,AQxBA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AGTA,AQxBA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AGTA,AQxBA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AGTA,AQxBA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AWjCA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AWjCA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AWjCA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AWjCA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AWjCA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AWjCA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AWjCA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AWjCA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AWjCA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AWjCA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AWjCA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AT2BA,AWjCA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AENA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AENA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AENA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AENA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AENA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AENA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,AENA,APqBA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,ALeA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,ALeA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,ALeA,AIZA,AZoCA;AczCA,AT2BA,AJYA,AU9BA,ADGA,AGTA,ALeA,AIZA,AZoCA;AczCA,AbuCA,AU9BA,ADGA,AGTA,ALeA,AIZA,AZoCA;AczCA,AbuCA,AU9BA,ADGA,AGTA,ALeA,AIZA,AZoCA;AczCA,AbuCA,AU9BA,ADGA,AGTA,ALeA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AGTA,ALeA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AGTA,ALeA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AGTA,ALeA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AGTA,ALeA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AGTA,ALeA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AGTA,ALeA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AGTA,ALeA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AGTA,ALeA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AGTA,ALeA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AGTA,ALeA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AGTA,ALeA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AGTA,ALeA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AGTA,ALeA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AGTA,ALeA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AFMA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AFMA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AFMA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AFMA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AFMA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AFMA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AFMA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AFMA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AFMA,AIZA,AZoCA;AczCA,AbuCA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AS3BA,AFMA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,AIZA,AZoCA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;ACFA,AOrBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AQvBA,ARwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n// classic singleton yargs API, to use yargs\n// without running as a singleton do:\n// require('yargs/yargs')(process.argv.slice(2))\nconst yargs = require('./yargs')\nconst processArgv = require('./build/lib/process-argv')\n\nArgv(processArgv.getProcessArgvWithoutBin())\n\nmodule.exports = Argv\n\nfunction Argv (processArgs, cwd) {\n  const argv = yargs(processArgs, cwd, require)\n  singletonify(argv)\n  return argv\n}\n\n/*  Hack an instance of Argv with process.argv into Argv\n    so people can do\n    require('yargs')(['--beeble=1','-z','zizzle']).argv\n    to parse a list of args and\n    require('yargs').argv\n    to get a parsed version of process.argv.\n*/\nfunction singletonify (inst) {\n  Object.keys(inst).forEach((key) => {\n    if (key === 'argv') {\n      Argv.__defineGetter__(key, inst.__lookupGetter__(key))\n    } else if (typeof inst[key] === 'function') {\n      Argv[key] = inst[key].bind(inst)\n    } else {\n      Argv.__defineGetter__('$0', () => {\n        return inst.$0\n      })\n      Argv.__defineGetter__('parsed', () => {\n        return inst.parsed\n      })\n    }\n  })\n}\n","\n\n// an async function fails early in Node.js versions prior to 8.\nasync function requiresNode8OrGreater () {}\nrequiresNode8OrGreater()\n\nconst { Yargs, rebase } = require('./build/lib/yargs')\nconst Parser = require('yargs-parser')\n\nexports = module.exports = Yargs\nexports.rebase = rebase\n\n// allow consumers to directly use the version of yargs-parser used by yargs\nexports.Parser = Parser\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isYargsInstance = exports.rebase = exports.Yargs = void 0;\nconst command_1 = require(\"./command\");\nconst common_types_1 = require(\"./common-types\");\nconst yerror_1 = require(\"./yerror\");\nconst usage_1 = require(\"./usage\");\nconst argsert_1 = require(\"./argsert\");\nconst fs = require(\"fs\");\nconst completion_1 = require(\"./completion\");\nconst path = require(\"path\");\nconst validation_1 = require(\"./validation\");\nconst obj_filter_1 = require(\"./obj-filter\");\nconst apply_extends_1 = require(\"./apply-extends\");\nconst middleware_1 = require(\"./middleware\");\nconst processArgv = require(\"./process-argv\");\nconst is_promise_1 = require(\"./is-promise\");\nconst Parser = require(\"yargs-parser\");\nconst y18nFactory = require(\"y18n\");\nconst setBlocking = require(\"set-blocking\");\nconst findUp = require(\"find-up\");\nconst requireMainFilename = require(\"require-main-filename\");\nfunction Yargs(processArgs = [], cwd = process.cwd(), parentRequire = require) {\n    const self = {};\n    let command;\n    let completion = null;\n    let groups = {};\n    const globalMiddleware = [];\n    let output = '';\n    const preservedGroups = {};\n    let usage;\n    let validation;\n    let handlerFinishCommand = null;\n    const y18n = y18nFactory({\n        directory: path.resolve(__dirname, '../../locales'),\n        updateFiles: false\n    });\n    self.middleware = middleware_1.globalMiddlewareFactory(globalMiddleware, self);\n    self.scriptName = function (scriptName) {\n        self.customScriptName = true;\n        self.$0 = scriptName;\n        return self;\n    };\n    // ignore the node bin, specify this in your\n    // bin file with #!/usr/bin/env node\n    let default$0;\n    if (/\\b(node|iojs|electron)(\\.exe)?$/.test(process.argv[0])) {\n        default$0 = process.argv.slice(1, 2);\n    }\n    else {\n        default$0 = process.argv.slice(0, 1);\n    }\n    self.$0 = default$0\n        .map(x => {\n        const b = rebase(cwd, x);\n        return x.match(/^(\\/|([a-zA-Z]:)?\\\\)/) && b.length < x.length ? b : x;\n    })\n        .join(' ').trim();\n    if (process.env._ !== undefined && processArgv.getProcessArgvBin() === process.env._) {\n        self.$0 = process.env._.replace(`${path.dirname(process.execPath)}/`, '');\n    }\n    // use context object to keep track of resets, subcommand execution, etc\n    // submodules should modify and check the state of context as necessary\n    const context = { resets: -1, commands: [], fullCommands: [], files: [] };\n    self.getContext = () => context;\n    // puts yargs back into an initial state. any keys\n    // that have been set to \"global\" will not be reset\n    // by this action.\n    let options;\n    self.resetOptions = self.reset = function resetOptions(aliases = {}) {\n        context.resets++;\n        options = options || {};\n        // put yargs back into an initial state, this\n        // logic is used to build a nested command\n        // hierarchy.\n        const tmpOptions = {};\n        tmpOptions.local = options.local ? options.local : [];\n        tmpOptions.configObjects = options.configObjects ? options.configObjects : [];\n        // if a key has been explicitly set as local,\n        // we should reset it before passing options to command.\n        const localLookup = {};\n        tmpOptions.local.forEach((l) => {\n            localLookup[l] = true;\n            (aliases[l] || []).forEach((a) => {\n                localLookup[a] = true;\n            });\n        });\n        // add all groups not set to local to preserved groups\n        Object.assign(preservedGroups, Object.keys(groups).reduce((acc, groupName) => {\n            const keys = groups[groupName].filter(key => !(key in localLookup));\n            if (keys.length > 0) {\n                acc[groupName] = keys;\n            }\n            return acc;\n        }, {}));\n        // groups can now be reset\n        groups = {};\n        const arrayOptions = [\n            'array', 'boolean', 'string', 'skipValidation',\n            'count', 'normalize', 'number',\n            'hiddenOptions'\n        ];\n        const objectOptions = [\n            'narg', 'key', 'alias', 'default', 'defaultDescription',\n            'config', 'choices', 'demandedOptions', 'demandedCommands', 'coerce',\n            'deprecatedOptions'\n        ];\n        arrayOptions.forEach(k => {\n            tmpOptions[k] = (options[k] || []).filter(k => !localLookup[k]);\n        });\n        objectOptions.forEach((k) => {\n            tmpOptions[k] = obj_filter_1.objFilter(options[k], k => !localLookup[k]);\n        });\n        tmpOptions.envPrefix = options.envPrefix;\n        options = tmpOptions;\n        // if this is the first time being executed, create\n        // instances of all our helpers -- otherwise just reset.\n        usage = usage ? usage.reset(localLookup) : usage_1.usage(self, y18n);\n        validation = validation ? validation.reset(localLookup) : validation_1.validation(self, usage, y18n);\n        command = command ? command.reset() : command_1.command(self, usage, validation, globalMiddleware);\n        if (!completion)\n            completion = completion_1.completion(self, usage, command);\n        completionCommand = null;\n        output = '';\n        exitError = null;\n        hasOutput = false;\n        self.parsed = false;\n        return self;\n    };\n    self.resetOptions();\n    // temporary hack: allow \"freezing\" of reset-able state for parse(msg, cb)\n    const frozens = [];\n    function freeze() {\n        frozens.push({\n            options,\n            configObjects: options.configObjects.slice(0),\n            exitProcess,\n            groups,\n            strict,\n            strictCommands,\n            completionCommand,\n            output,\n            exitError,\n            hasOutput,\n            parsed: self.parsed,\n            parseFn,\n            parseContext,\n            handlerFinishCommand\n        });\n        usage.freeze();\n        validation.freeze();\n        command.freeze();\n    }\n    function unfreeze() {\n        const frozen = frozens.pop();\n        common_types_1.assertNotStrictEqual(frozen, undefined);\n        let configObjects;\n        ({\n            options,\n            configObjects,\n            exitProcess,\n            groups,\n            output,\n            exitError,\n            hasOutput,\n            parsed: self.parsed,\n            strict,\n            strictCommands,\n            completionCommand,\n            parseFn,\n            parseContext,\n            handlerFinishCommand\n        } = frozen);\n        options.configObjects = configObjects;\n        usage.unfreeze();\n        validation.unfreeze();\n        command.unfreeze();\n    }\n    self.boolean = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('boolean', keys);\n        return self;\n    };\n    self.array = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('array', keys);\n        return self;\n    };\n    self.number = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('number', keys);\n        return self;\n    };\n    self.normalize = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('normalize', keys);\n        return self;\n    };\n    self.count = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('count', keys);\n        return self;\n    };\n    self.string = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('string', keys);\n        return self;\n    };\n    self.requiresArg = function (keys) {\n        // the 2nd paramter [number] in the argsert the assertion is mandatory\n        // as populateParserHintSingleValueDictionary recursively calls requiresArg\n        // with Nan as a 2nd parameter, although we ignore it\n        argsert_1.argsert('<array|string|object> [number]', [keys], arguments.length);\n        // If someone configures nargs at the same time as requiresArg,\n        // nargs should take precedent,\n        // see: https://github.com/yargs/yargs/pull/1572\n        // TODO: make this work with aliases, using a check similar to\n        // checkAllAliases() in yargs-parser.\n        if (typeof keys === 'string' && options.narg[keys]) {\n            return self;\n        }\n        else {\n            populateParserHintSingleValueDictionary(self.requiresArg, 'narg', keys, NaN);\n        }\n        return self;\n    };\n    self.skipValidation = function (keys) {\n        argsert_1.argsert('<array|string>', [keys], arguments.length);\n        populateParserHintArray('skipValidation', keys);\n        return self;\n    };\n    function populateParserHintArray(type, keys) {\n        keys = [].concat(keys);\n        keys.forEach((key) => {\n            key = sanitizeKey(key);\n            options[type].push(key);\n        });\n    }\n    self.nargs = function (key, value) {\n        argsert_1.argsert('<string|object|array> [number]', [key, value], arguments.length);\n        populateParserHintSingleValueDictionary(self.nargs, 'narg', key, value);\n        return self;\n    };\n    self.choices = function (key, value) {\n        argsert_1.argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n        populateParserHintArrayDictionary(self.choices, 'choices', key, value);\n        return self;\n    };\n    self.alias = function (key, value) {\n        argsert_1.argsert('<object|string|array> [string|array]', [key, value], arguments.length);\n        populateParserHintArrayDictionary(self.alias, 'alias', key, value);\n        return self;\n    };\n    // TODO: actually deprecate self.defaults.\n    self.default = self.defaults = function (key, value, defaultDescription) {\n        argsert_1.argsert('<object|string|array> [*] [string]', [key, value, defaultDescription], arguments.length);\n        if (defaultDescription) {\n            common_types_1.assertSingleKey(key);\n            options.defaultDescription[key] = defaultDescription;\n        }\n        if (typeof value === 'function') {\n            common_types_1.assertSingleKey(key);\n            if (!options.defaultDescription[key])\n                options.defaultDescription[key] = usage.functionDescription(value);\n            value = value.call();\n        }\n        populateParserHintSingleValueDictionary(self.default, 'default', key, value);\n        return self;\n    };\n    self.describe = function (key, desc) {\n        argsert_1.argsert('<object|string|array> [string]', [key, desc], arguments.length);\n        setKey(key, true);\n        usage.describe(key, desc);\n        return self;\n    };\n    function setKey(key, set) {\n        populateParserHintSingleValueDictionary(setKey, 'key', key, set);\n        return self;\n    }\n    function demandOption(keys, msg) {\n        argsert_1.argsert('<object|string|array> [string]', [keys, msg], arguments.length);\n        populateParserHintSingleValueDictionary(self.demandOption, 'demandedOptions', keys, msg);\n        return self;\n    }\n    self.demandOption = demandOption;\n    self.coerce = function (keys, value) {\n        argsert_1.argsert('<object|string|array> [function]', [keys, value], arguments.length);\n        populateParserHintSingleValueDictionary(self.coerce, 'coerce', keys, value);\n        return self;\n    };\n    function populateParserHintSingleValueDictionary(builder, type, key, value) {\n        populateParserHintDictionary(builder, type, key, value, (type, key, value) => {\n            options[type][key] = value;\n        });\n    }\n    function populateParserHintArrayDictionary(builder, type, key, value) {\n        populateParserHintDictionary(builder, type, key, value, (type, key, value) => {\n            options[type][key] = (options[type][key] || []).concat(value);\n        });\n    }\n    function populateParserHintDictionary(builder, type, key, value, singleKeyHandler) {\n        if (Array.isArray(key)) {\n            // an array of keys with one value ['x', 'y', 'z'], function parse () {}\n            key.forEach((k) => {\n                builder(k, value);\n            });\n        }\n        else if (((key) => typeof key === 'object')(key)) {\n            // an object of key value pairs: {'x': parse () {}, 'y': parse() {}}\n            for (const k of common_types_1.objectKeys(key)) {\n                builder(k, key[k]);\n            }\n        }\n        else {\n            singleKeyHandler(type, sanitizeKey(key), value);\n        }\n    }\n    function sanitizeKey(key) {\n        if (key === '__proto__')\n            return '___proto___';\n        return key;\n    }\n    function deleteFromParserHintObject(optionKey) {\n        // delete from all parsing hints:\n        // boolean, array, key, alias, etc.\n        common_types_1.objectKeys(options).forEach((hintKey) => {\n            // configObjects is not a parsing hint array\n            if (((key) => key === 'configObjects')(hintKey))\n                return;\n            const hint = options[hintKey];\n            if (Array.isArray(hint)) {\n                if (~hint.indexOf(optionKey))\n                    hint.splice(hint.indexOf(optionKey), 1);\n            }\n            else if (typeof hint === 'object') {\n                delete hint[optionKey];\n            }\n        });\n        // now delete the description from usage.js.\n        delete usage.getDescriptions()[optionKey];\n    }\n    self.config = function config(key = 'config', msg, parseFn) {\n        argsert_1.argsert('[object|string] [string|function] [function]', [key, msg, parseFn], arguments.length);\n        // allow a config object to be provided directly.\n        if ((typeof key === 'object') && !Array.isArray(key)) {\n            key = apply_extends_1.applyExtends(key, cwd, self.getParserConfiguration()['deep-merge-config']);\n            options.configObjects = (options.configObjects || []).concat(key);\n            return self;\n        }\n        // allow for a custom parsing function.\n        if (typeof msg === 'function') {\n            parseFn = msg;\n            msg = undefined;\n        }\n        self.describe(key, msg || usage.deferY18nLookup('Path to JSON config file'));\n        (Array.isArray(key) ? key : [key]).forEach((k) => {\n            options.config[k] = parseFn || true;\n        });\n        return self;\n    };\n    self.example = function (cmd, description) {\n        argsert_1.argsert('<string|array> [string]', [cmd, description], arguments.length);\n        if (Array.isArray(cmd)) {\n            cmd.forEach((exampleParams) => self.example(...exampleParams));\n        }\n        else {\n            usage.example(cmd, description);\n        }\n        return self;\n    };\n    self.command = function (cmd, description, builder, handler, middlewares, deprecated) {\n        argsert_1.argsert('<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]', [cmd, description, builder, handler, middlewares, deprecated], arguments.length);\n        command.addHandler(cmd, description, builder, handler, middlewares, deprecated);\n        return self;\n    };\n    self.commandDir = function (dir, opts) {\n        argsert_1.argsert('<string> [object]', [dir, opts], arguments.length);\n        const req = parentRequire || require;\n        command.addDirectory(dir, self.getContext(), req, require('get-caller-file')(), opts);\n        return self;\n    };\n    // TODO: deprecate self.demand in favor of\n    // .demandCommand() .demandOption().\n    self.demand = self.required = self.require = function demand(keys, max, msg) {\n        // you can optionally provide a 'max' key,\n        // which will raise an exception if too many '_'\n        // options are provided.\n        if (Array.isArray(max)) {\n            max.forEach((key) => {\n                common_types_1.assertNotStrictEqual(msg, true);\n                demandOption(key, msg);\n            });\n            max = Infinity;\n        }\n        else if (typeof max !== 'number') {\n            msg = max;\n            max = Infinity;\n        }\n        if (typeof keys === 'number') {\n            common_types_1.assertNotStrictEqual(msg, true);\n            self.demandCommand(keys, max, msg, msg);\n        }\n        else if (Array.isArray(keys)) {\n            keys.forEach((key) => {\n                common_types_1.assertNotStrictEqual(msg, true);\n                demandOption(key, msg);\n            });\n        }\n        else {\n            if (typeof msg === 'string') {\n                demandOption(keys, msg);\n            }\n            else if (msg === true || typeof msg === 'undefined') {\n                demandOption(keys);\n            }\n        }\n        return self;\n    };\n    self.demandCommand = function demandCommand(min = 1, max, minMsg, maxMsg) {\n        argsert_1.argsert('[number] [number|string] [string|null|undefined] [string|null|undefined]', [min, max, minMsg, maxMsg], arguments.length);\n        if (typeof max !== 'number') {\n            minMsg = max;\n            max = Infinity;\n        }\n        self.global('_', false);\n        options.demandedCommands._ = {\n            min,\n            max,\n            minMsg,\n            maxMsg\n        };\n        return self;\n    };\n    self.getDemandedOptions = () => {\n        argsert_1.argsert([], 0);\n        return options.demandedOptions;\n    };\n    self.getDemandedCommands = () => {\n        argsert_1.argsert([], 0);\n        return options.demandedCommands;\n    };\n    self.deprecateOption = function deprecateOption(option, message) {\n        argsert_1.argsert('<string> [string|boolean]', [option, message], arguments.length);\n        options.deprecatedOptions[option] = message;\n        return self;\n    };\n    self.getDeprecatedOptions = () => {\n        argsert_1.argsert([], 0);\n        return options.deprecatedOptions;\n    };\n    self.implies = function (key, value) {\n        argsert_1.argsert('<string|object> [number|string|array]', [key, value], arguments.length);\n        validation.implies(key, value);\n        return self;\n    };\n    self.conflicts = function (key1, key2) {\n        argsert_1.argsert('<string|object> [string|array]', [key1, key2], arguments.length);\n        validation.conflicts(key1, key2);\n        return self;\n    };\n    self.usage = function (msg, description, builder, handler) {\n        argsert_1.argsert('<string|null|undefined> [string|boolean] [function|object] [function]', [msg, description, builder, handler], arguments.length);\n        if (description !== undefined) {\n            common_types_1.assertNotStrictEqual(msg, null);\n            // .usage() can be used as an alias for defining\n            // a default command.\n            if ((msg || '').match(/^\\$0( |$)/)) {\n                return self.command(msg, description, builder, handler);\n            }\n            else {\n                throw new yerror_1.YError('.usage() description must start with $0 if being used as alias for .command()');\n            }\n        }\n        else {\n            usage.usage(msg);\n            return self;\n        }\n    };\n    self.epilogue = self.epilog = function (msg) {\n        argsert_1.argsert('<string>', [msg], arguments.length);\n        usage.epilog(msg);\n        return self;\n    };\n    self.fail = function (f) {\n        argsert_1.argsert('<function>', [f], arguments.length);\n        usage.failFn(f);\n        return self;\n    };\n    self.onFinishCommand = function (f) {\n        argsert_1.argsert('<function>', [f], arguments.length);\n        handlerFinishCommand = f;\n        return self;\n    };\n    self.getHandlerFinishCommand = () => handlerFinishCommand;\n    self.check = function (f, _global) {\n        argsert_1.argsert('<function> [boolean]', [f, _global], arguments.length);\n        validation.check(f, _global !== false);\n        return self;\n    };\n    self.global = function global(globals, global) {\n        argsert_1.argsert('<string|array> [boolean]', [globals, global], arguments.length);\n        globals = [].concat(globals);\n        if (global !== false) {\n            options.local = options.local.filter(l => globals.indexOf(l) === -1);\n        }\n        else {\n            globals.forEach((g) => {\n                if (options.local.indexOf(g) === -1)\n                    options.local.push(g);\n            });\n        }\n        return self;\n    };\n    self.pkgConf = function pkgConf(key, rootPath) {\n        argsert_1.argsert('<string> [string]', [key, rootPath], arguments.length);\n        let conf = null;\n        // prefer cwd to require-main-filename in this method\n        // since we're looking for e.g. \"nyc\" config in nyc consumer\n        // rather than \"yargs\" config in nyc (where nyc is the main filename)\n        const obj = pkgUp(rootPath || cwd);\n        // If an object exists in the key, add it to options.configObjects\n        if (obj[key] && typeof obj[key] === 'object') {\n            conf = apply_extends_1.applyExtends(obj[key], rootPath || cwd, self.getParserConfiguration()['deep-merge-config']);\n            options.configObjects = (options.configObjects || []).concat(conf);\n        }\n        return self;\n    };\n    const pkgs = {};\n    function pkgUp(rootPath) {\n        const npath = rootPath || '*';\n        if (pkgs[npath])\n            return pkgs[npath];\n        let obj = {};\n        try {\n            let startDir = rootPath || requireMainFilename(parentRequire);\n            // When called in an environment that lacks require.main.filename, such as a jest test runner,\n            // startDir is already process.cwd(), and should not be shortened.\n            // Whether or not it is _actually_ a directory (e.g., extensionless bin) is irrelevant, find-up handles it.\n            if (!rootPath && path.extname(startDir)) {\n                startDir = path.dirname(startDir);\n            }\n            const pkgJsonPath = findUp.sync('package.json', {\n                cwd: startDir\n            });\n            common_types_1.assertNotStrictEqual(pkgJsonPath, undefined);\n            obj = JSON.parse(fs.readFileSync(pkgJsonPath).toString());\n        }\n        catch (noop) { }\n        pkgs[npath] = obj || {};\n        return pkgs[npath];\n    }\n    let parseFn = null;\n    let parseContext = null;\n    self.parse = function parse(args, shortCircuit, _parseFn) {\n        argsert_1.argsert('[string|array] [function|boolean|object] [function]', [args, shortCircuit, _parseFn], arguments.length);\n        freeze();\n        if (typeof args === 'undefined') {\n            const argv = self._parseArgs(processArgs);\n            const tmpParsed = self.parsed;\n            unfreeze();\n            // TODO: remove this compatibility hack when we release yargs@15.x:\n            self.parsed = tmpParsed;\n            return argv;\n        }\n        // a context object can optionally be provided, this allows\n        // additional information to be passed to a command handler.\n        if (typeof shortCircuit === 'object') {\n            parseContext = shortCircuit;\n            shortCircuit = _parseFn;\n        }\n        // by providing a function as a second argument to\n        // parse you can capture output that would otherwise\n        // default to printing to stdout/stderr.\n        if (typeof shortCircuit === 'function') {\n            parseFn = shortCircuit;\n            shortCircuit = false;\n        }\n        // completion short-circuits the parsing process,\n        // skipping validation, etc.\n        if (!shortCircuit)\n            processArgs = args;\n        if (parseFn)\n            exitProcess = false;\n        const parsed = self._parseArgs(args, !!shortCircuit);\n        completion.setParsed(self.parsed);\n        if (parseFn)\n            parseFn(exitError, parsed, output);\n        unfreeze();\n        return parsed;\n    };\n    self._getParseContext = () => parseContext || {};\n    self._hasParseCallback = () => !!parseFn;\n    self.option = self.options = function option(key, opt) {\n        argsert_1.argsert('<string|object> [object]', [key, opt], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach((k) => {\n                self.options(k, key[k]);\n            });\n        }\n        else {\n            if (typeof opt !== 'object') {\n                opt = {};\n            }\n            options.key[key] = true; // track manually set keys.\n            if (opt.alias)\n                self.alias(key, opt.alias);\n            const deprecate = opt.deprecate || opt.deprecated;\n            if (deprecate) {\n                self.deprecateOption(key, deprecate);\n            }\n            const demand = opt.demand || opt.required || opt.require;\n            // A required option can be specified via \"demand: true\".\n            if (demand) {\n                self.demand(key, demand);\n            }\n            if (opt.demandOption) {\n                self.demandOption(key, typeof opt.demandOption === 'string' ? opt.demandOption : undefined);\n            }\n            if (opt.conflicts) {\n                self.conflicts(key, opt.conflicts);\n            }\n            if ('default' in opt) {\n                self.default(key, opt.default);\n            }\n            if (opt.implies !== undefined) {\n                self.implies(key, opt.implies);\n            }\n            if (opt.nargs !== undefined) {\n                self.nargs(key, opt.nargs);\n            }\n            if (opt.config) {\n                self.config(key, opt.configParser);\n            }\n            if (opt.normalize) {\n                self.normalize(key);\n            }\n            if (opt.choices) {\n                self.choices(key, opt.choices);\n            }\n            if (opt.coerce) {\n                self.coerce(key, opt.coerce);\n            }\n            if (opt.group) {\n                self.group(key, opt.group);\n            }\n            if (opt.boolean || opt.type === 'boolean') {\n                self.boolean(key);\n                if (opt.alias)\n                    self.boolean(opt.alias);\n            }\n            if (opt.array || opt.type === 'array') {\n                self.array(key);\n                if (opt.alias)\n                    self.array(opt.alias);\n            }\n            if (opt.number || opt.type === 'number') {\n                self.number(key);\n                if (opt.alias)\n                    self.number(opt.alias);\n            }\n            if (opt.string || opt.type === 'string') {\n                self.string(key);\n                if (opt.alias)\n                    self.string(opt.alias);\n            }\n            if (opt.count || opt.type === 'count') {\n                self.count(key);\n            }\n            if (typeof opt.global === 'boolean') {\n                self.global(key, opt.global);\n            }\n            if (opt.defaultDescription) {\n                options.defaultDescription[key] = opt.defaultDescription;\n            }\n            if (opt.skipValidation) {\n                self.skipValidation(key);\n            }\n            const desc = opt.describe || opt.description || opt.desc;\n            self.describe(key, desc);\n            if (opt.hidden) {\n                self.hide(key);\n            }\n            if (opt.requiresArg) {\n                self.requiresArg(key);\n            }\n        }\n        return self;\n    };\n    self.getOptions = () => options;\n    self.positional = function (key, opts) {\n        argsert_1.argsert('<string> <object>', [key, opts], arguments.length);\n        if (context.resets === 0) {\n            throw new yerror_1.YError(\".positional() can only be called in a command's builder function\");\n        }\n        // .positional() only supports a subset of the configuration\n        // options available to .option().\n        const supportedOpts = ['default', 'defaultDescription', 'implies', 'normalize',\n            'choices', 'conflicts', 'coerce', 'type', 'describe',\n            'desc', 'description', 'alias'];\n        opts = obj_filter_1.objFilter(opts, (k, v) => {\n            let accept = supportedOpts.indexOf(k) !== -1;\n            // type can be one of string|number|boolean.\n            if (k === 'type' && ['string', 'number', 'boolean'].indexOf(v) === -1)\n                accept = false;\n            return accept;\n        });\n        // copy over any settings that can be inferred from the command string.\n        const fullCommand = context.fullCommands[context.fullCommands.length - 1];\n        const parseOptions = fullCommand ? command.cmdToParseOptions(fullCommand) : {\n            array: [],\n            alias: {},\n            default: {},\n            demand: {}\n        };\n        common_types_1.objectKeys(parseOptions).forEach((pk) => {\n            const parseOption = parseOptions[pk];\n            if (Array.isArray(parseOption)) {\n                if (parseOption.indexOf(key) !== -1)\n                    opts[pk] = true;\n            }\n            else {\n                if (parseOption[key] && !(pk in opts))\n                    opts[pk] = parseOption[key];\n            }\n        });\n        self.group(key, usage.getPositionalGroupName());\n        return self.option(key, opts);\n    };\n    self.group = function group(opts, groupName) {\n        argsert_1.argsert('<string|array> <string>', [opts, groupName], arguments.length);\n        const existing = preservedGroups[groupName] || groups[groupName];\n        if (preservedGroups[groupName]) {\n            // we now only need to track this group name in groups.\n            delete preservedGroups[groupName];\n        }\n        const seen = {};\n        groups[groupName] = (existing || []).concat(opts).filter((key) => {\n            if (seen[key])\n                return false;\n            return (seen[key] = true);\n        });\n        return self;\n    };\n    // combine explicit and preserved groups. explicit groups should be first\n    self.getGroups = () => Object.assign({}, groups, preservedGroups);\n    // as long as options.envPrefix is not undefined,\n    // parser will apply env vars matching prefix to argv\n    self.env = function (prefix) {\n        argsert_1.argsert('[string|boolean]', [prefix], arguments.length);\n        if (prefix === false)\n            delete options.envPrefix;\n        else\n            options.envPrefix = prefix || '';\n        return self;\n    };\n    self.wrap = function (cols) {\n        argsert_1.argsert('<number|null|undefined>', [cols], arguments.length);\n        usage.wrap(cols);\n        return self;\n    };\n    let strict = false;\n    self.strict = function (enabled) {\n        argsert_1.argsert('[boolean]', [enabled], arguments.length);\n        strict = enabled !== false;\n        return self;\n    };\n    self.getStrict = () => strict;\n    let strictCommands = false;\n    self.strictCommands = function (enabled) {\n        argsert_1.argsert('[boolean]', [enabled], arguments.length);\n        strictCommands = enabled !== false;\n        return self;\n    };\n    self.getStrictCommands = () => strictCommands;\n    let parserConfig = {};\n    self.parserConfiguration = function parserConfiguration(config) {\n        argsert_1.argsert('<object>', [config], arguments.length);\n        parserConfig = config;\n        return self;\n    };\n    self.getParserConfiguration = () => parserConfig;\n    self.showHelp = function (level) {\n        argsert_1.argsert('[string|function]', [level], arguments.length);\n        if (!self.parsed)\n            self._parseArgs(processArgs); // run parser, if it has not already been executed.\n        if (command.hasDefaultCommand()) {\n            context.resets++; // override the restriction on top-level positoinals.\n            command.runDefaultBuilderOn(self);\n        }\n        usage.showHelp(level);\n        return self;\n    };\n    let versionOpt = null;\n    self.version = function version(opt, msg, ver) {\n        const defaultVersionOpt = 'version';\n        argsert_1.argsert('[boolean|string] [string] [string]', [opt, msg, ver], arguments.length);\n        // nuke the key previously configured\n        // to return version #.\n        if (versionOpt) {\n            deleteFromParserHintObject(versionOpt);\n            usage.version(undefined);\n            versionOpt = null;\n        }\n        if (arguments.length === 0) {\n            ver = guessVersion();\n            opt = defaultVersionOpt;\n        }\n        else if (arguments.length === 1) {\n            if (opt === false) { // disable default 'version' key.\n                return self;\n            }\n            ver = opt;\n            opt = defaultVersionOpt;\n        }\n        else if (arguments.length === 2) {\n            ver = msg;\n            msg = undefined;\n        }\n        versionOpt = typeof opt === 'string' ? opt : defaultVersionOpt;\n        msg = msg || usage.deferY18nLookup('Show version number');\n        usage.version(ver || undefined);\n        self.boolean(versionOpt);\n        self.describe(versionOpt, msg);\n        return self;\n    };\n    function guessVersion() {\n        const obj = pkgUp();\n        return obj.version || 'unknown';\n    }\n    let helpOpt = null;\n    self.addHelpOpt = self.help = function addHelpOpt(opt, msg) {\n        const defaultHelpOpt = 'help';\n        argsert_1.argsert('[string|boolean] [string]', [opt, msg], arguments.length);\n        // nuke the key previously configured\n        // to return help.\n        if (helpOpt) {\n            deleteFromParserHintObject(helpOpt);\n            helpOpt = null;\n        }\n        if (arguments.length === 1) {\n            if (opt === false)\n                return self;\n        }\n        // use arguments, fallback to defaults for opt and msg\n        helpOpt = typeof opt === 'string' ? opt : defaultHelpOpt;\n        self.boolean(helpOpt);\n        self.describe(helpOpt, msg || usage.deferY18nLookup('Show help'));\n        return self;\n    };\n    const defaultShowHiddenOpt = 'show-hidden';\n    options.showHiddenOpt = defaultShowHiddenOpt;\n    self.addShowHiddenOpt = self.showHidden = function addShowHiddenOpt(opt, msg) {\n        argsert_1.argsert('[string|boolean] [string]', [opt, msg], arguments.length);\n        if (arguments.length === 1) {\n            if (opt === false)\n                return self;\n        }\n        const showHiddenOpt = typeof opt === 'string' ? opt : defaultShowHiddenOpt;\n        self.boolean(showHiddenOpt);\n        self.describe(showHiddenOpt, msg || usage.deferY18nLookup('Show hidden options'));\n        options.showHiddenOpt = showHiddenOpt;\n        return self;\n    };\n    self.hide = function hide(key) {\n        argsert_1.argsert('<string>', [key], arguments.length);\n        options.hiddenOptions.push(key);\n        return self;\n    };\n    self.showHelpOnFail = function showHelpOnFail(enabled, message) {\n        argsert_1.argsert('[boolean|string] [string]', [enabled, message], arguments.length);\n        usage.showHelpOnFail(enabled, message);\n        return self;\n    };\n    var exitProcess = true;\n    self.exitProcess = function (enabled = true) {\n        argsert_1.argsert('[boolean]', [enabled], arguments.length);\n        exitProcess = enabled;\n        return self;\n    };\n    self.getExitProcess = () => exitProcess;\n    var completionCommand = null;\n    self.completion = function (cmd, desc, fn) {\n        argsert_1.argsert('[string] [string|boolean|function] [function]', [cmd, desc, fn], arguments.length);\n        // a function to execute when generating\n        // completions can be provided as the second\n        // or third argument to completion.\n        if (typeof desc === 'function') {\n            fn = desc;\n            desc = undefined;\n        }\n        // register the completion command.\n        completionCommand = cmd || completionCommand || 'completion';\n        if (!desc && desc !== false) {\n            desc = 'generate completion script';\n        }\n        self.command(completionCommand, desc);\n        // a function can be provided\n        if (fn)\n            completion.registerFunction(fn);\n        return self;\n    };\n    self.showCompletionScript = function ($0, cmd) {\n        argsert_1.argsert('[string] [string]', [$0, cmd], arguments.length);\n        $0 = $0 || self.$0;\n        _logger.log(completion.generateCompletionScript($0, cmd || completionCommand || 'completion'));\n        return self;\n    };\n    self.getCompletion = function (args, done) {\n        argsert_1.argsert('<array> <function>', [args, done], arguments.length);\n        completion.getCompletion(args, done);\n    };\n    self.locale = function (locale) {\n        argsert_1.argsert('[string]', [locale], arguments.length);\n        if (!locale) {\n            guessLocale();\n            return y18n.getLocale();\n        }\n        detectLocale = false;\n        y18n.setLocale(locale);\n        return self;\n    };\n    self.updateStrings = self.updateLocale = function (obj) {\n        argsert_1.argsert('<object>', [obj], arguments.length);\n        detectLocale = false;\n        y18n.updateLocale(obj);\n        return self;\n    };\n    let detectLocale = true;\n    self.detectLocale = function (detect) {\n        argsert_1.argsert('<boolean>', [detect], arguments.length);\n        detectLocale = detect;\n        return self;\n    };\n    self.getDetectLocale = () => detectLocale;\n    var hasOutput = false;\n    var exitError = null;\n    // maybe exit, always capture\n    // context about why we wanted to exit.\n    self.exit = (code, err) => {\n        hasOutput = true;\n        exitError = err;\n        if (exitProcess)\n            process.exit(code);\n    };\n    // we use a custom logger that buffers output,\n    // so that we can print to non-CLIs, e.g., chat-bots.\n    const _logger = {\n        log(...args) {\n            if (!self._hasParseCallback())\n                console.log(...args);\n            hasOutput = true;\n            if (output.length)\n                output += '\\n';\n            output += args.join(' ');\n        },\n        error(...args) {\n            if (!self._hasParseCallback())\n                console.error(...args);\n            hasOutput = true;\n            if (output.length)\n                output += '\\n';\n            output += args.join(' ');\n        }\n    };\n    self._getLoggerInstance = () => _logger;\n    // has yargs output an error our help\n    // message in the current execution context.\n    self._hasOutput = () => hasOutput;\n    self._setHasOutput = () => {\n        hasOutput = true;\n    };\n    let recommendCommands;\n    self.recommendCommands = function (recommend = true) {\n        argsert_1.argsert('[boolean]', [recommend], arguments.length);\n        recommendCommands = recommend;\n        return self;\n    };\n    self.getUsageInstance = () => usage;\n    self.getValidationInstance = () => validation;\n    self.getCommandInstance = () => command;\n    self.terminalWidth = () => {\n        argsert_1.argsert([], 0);\n        return typeof process.stdout.columns !== 'undefined' ? process.stdout.columns : null;\n    };\n    Object.defineProperty(self, 'argv', {\n        get: () => self._parseArgs(processArgs),\n        enumerable: true\n    });\n    self._parseArgs = function parseArgs(args, shortCircuit, _calledFromCommand, commandIndex) {\n        let skipValidation = !!_calledFromCommand;\n        args = args || processArgs;\n        options.__ = y18n.__;\n        options.configuration = self.getParserConfiguration();\n        const populateDoubleDash = !!options.configuration['populate--'];\n        const config = Object.assign({}, options.configuration, {\n            'populate--': true\n        });\n        const parsed = Parser.detailed(args, Object.assign({}, options, {\n            configuration: config\n        }));\n        let argv = parsed.argv;\n        if (parseContext)\n            argv = Object.assign({}, argv, parseContext);\n        const aliases = parsed.aliases;\n        argv.$0 = self.$0;\n        self.parsed = parsed;\n        try {\n            guessLocale(); // guess locale lazily, so that it can be turned off in chain.\n            // while building up the argv object, there\n            // are two passes through the parser. If completion\n            // is being performed short-circuit on the first pass.\n            if (shortCircuit) {\n                return (populateDoubleDash || _calledFromCommand) ? argv : self._copyDoubleDash(argv);\n            }\n            // if there's a handler associated with a\n            // command defer processing to it.\n            if (helpOpt) {\n                // consider any multi-char helpOpt alias as a valid help command\n                // unless all helpOpt aliases are single-char\n                // note that parsed.aliases is a normalized bidirectional map :)\n                const helpCmds = [helpOpt]\n                    .concat(aliases[helpOpt] || [])\n                    .filter(k => k.length > 1);\n                // check if help should trigger and strip it from _.\n                if (~helpCmds.indexOf(argv._[argv._.length - 1])) {\n                    argv._.pop();\n                    argv[helpOpt] = true;\n                }\n            }\n            const handlerKeys = command.getCommands();\n            const requestCompletions = completion.completionKey in argv;\n            const skipRecommendation = argv[helpOpt] || requestCompletions;\n            const skipDefaultCommand = skipRecommendation && (handlerKeys.length > 1 || handlerKeys[0] !== '$0');\n            if (argv._.length) {\n                if (handlerKeys.length) {\n                    let firstUnknownCommand;\n                    for (let i = (commandIndex || 0), cmd; argv._[i] !== undefined; i++) {\n                        cmd = String(argv._[i]);\n                        if (~handlerKeys.indexOf(cmd) && cmd !== completionCommand) {\n                            // commands are executed using a recursive algorithm that executes\n                            // the deepest command first; we keep track of the position in the\n                            // argv._ array that is currently being executed.\n                            const innerArgv = command.runCommand(cmd, self, parsed, i + 1);\n                            return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);\n                        }\n                        else if (!firstUnknownCommand && cmd !== completionCommand) {\n                            firstUnknownCommand = cmd;\n                            break;\n                        }\n                    }\n                    // run the default command, if defined\n                    if (command.hasDefaultCommand() && !skipDefaultCommand) {\n                        const innerArgv = command.runCommand(null, self, parsed);\n                        return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);\n                    }\n                    // recommend a command if recommendCommands() has\n                    // been enabled, and no commands were found to execute\n                    if (recommendCommands && firstUnknownCommand && !skipRecommendation) {\n                        validation.recommendCommands(firstUnknownCommand, handlerKeys);\n                    }\n                }\n                // generate a completion script for adding to ~/.bashrc.\n                if (completionCommand && ~argv._.indexOf(completionCommand) && !requestCompletions) {\n                    if (exitProcess)\n                        setBlocking(true);\n                    self.showCompletionScript();\n                    self.exit(0);\n                }\n            }\n            else if (command.hasDefaultCommand() && !skipDefaultCommand) {\n                const innerArgv = command.runCommand(null, self, parsed);\n                return populateDoubleDash ? innerArgv : self._copyDoubleDash(innerArgv);\n            }\n            // we must run completions first, a user might\n            // want to complete the --help or --version option.\n            if (requestCompletions) {\n                if (exitProcess)\n                    setBlocking(true);\n                // we allow for asynchronous completions,\n                // e.g., loading in a list of commands from an API.\n                args = [].concat(args);\n                const completionArgs = args.slice(args.indexOf(`--${completion.completionKey}`) + 1);\n                completion.getCompletion(completionArgs, (completions) => {\n                    ;\n                    (completions || []).forEach((completion) => {\n                        _logger.log(completion);\n                    });\n                    self.exit(0);\n                });\n                return (populateDoubleDash || _calledFromCommand) ? argv : self._copyDoubleDash(argv);\n            }\n            // Handle 'help' and 'version' options\n            // if we haven't already output help!\n            if (!hasOutput) {\n                Object.keys(argv).forEach((key) => {\n                    if (key === helpOpt && argv[key]) {\n                        if (exitProcess)\n                            setBlocking(true);\n                        skipValidation = true;\n                        self.showHelp('log');\n                        self.exit(0);\n                    }\n                    else if (key === versionOpt && argv[key]) {\n                        if (exitProcess)\n                            setBlocking(true);\n                        skipValidation = true;\n                        usage.showVersion();\n                        self.exit(0);\n                    }\n                });\n            }\n            // Check if any of the options to skip validation were provided\n            if (!skipValidation && options.skipValidation.length > 0) {\n                skipValidation = Object.keys(argv).some(key => options.skipValidation.indexOf(key) >= 0 && argv[key] === true);\n            }\n            // If the help or version options where used and exitProcess is false,\n            // or if explicitly skipped, we won't run validations.\n            if (!skipValidation) {\n                if (parsed.error)\n                    throw new yerror_1.YError(parsed.error.message);\n                // if we're executed via bash completion, don't\n                // bother with validation.\n                if (!requestCompletions) {\n                    self._runValidation(argv, aliases, {}, parsed.error);\n                }\n            }\n        }\n        catch (err) {\n            if (err instanceof yerror_1.YError)\n                usage.fail(err.message, err);\n            else\n                throw err;\n        }\n        return (populateDoubleDash || _calledFromCommand) ? argv : self._copyDoubleDash(argv);\n    };\n    // to simplify the parsing of positionals in commands,\n    // we temporarily populate '--' rather than _, with arguments\n    // after the '--' directive. After the parse, we copy these back.\n    self._copyDoubleDash = function (argv) {\n        if (is_promise_1.isPromise(argv) || !argv._ || !argv['--'])\n            return argv;\n        argv._.push.apply(argv._, argv['--']);\n        // TODO(bcoe): refactor command parsing such that this delete is not\n        // necessary: https://github.com/yargs/yargs/issues/1482\n        try {\n            delete argv['--'];\n        }\n        catch (_err) { }\n        return argv;\n    };\n    self._runValidation = function runValidation(argv, aliases, positionalMap, parseErrors, isDefaultCommand = false) {\n        if (parseErrors)\n            throw new yerror_1.YError(parseErrors.message);\n        validation.nonOptionCount(argv);\n        validation.requiredArguments(argv);\n        let failedStrictCommands = false;\n        if (strictCommands) {\n            failedStrictCommands = validation.unknownCommands(argv);\n        }\n        if (strict && !failedStrictCommands) {\n            validation.unknownArguments(argv, aliases, positionalMap, isDefaultCommand);\n        }\n        validation.customChecks(argv, aliases);\n        validation.limitedChoices(argv);\n        validation.implications(argv);\n        validation.conflicting(argv);\n    };\n    function guessLocale() {\n        if (!detectLocale)\n            return;\n        const locale = process.env.LC_ALL || process.env.LC_MESSAGES || process.env.LANG || process.env.LANGUAGE || 'en_US';\n        self.locale(locale.replace(/[.:].*/, ''));\n    }\n    // an app should almost always have --version and --help,\n    // if you *really* want to disable this use .help(false)/.version(false).\n    self.help();\n    self.version();\n    return self;\n}\nexports.Yargs = Yargs;\n// rebase an absolute path to a relative one with respect to a base directory\n// exported for tests\nfunction rebase(base, dir) {\n    return path.relative(base, dir);\n}\nexports.rebase = rebase;\nfunction isYargsInstance(y) {\n    return !!y && (typeof y._parseArgs === 'function');\n}\nexports.isYargsInstance = isYargsInstance;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isCommandBuilderCallback = exports.isCommandBuilderDefinition = exports.isCommandHandlerDefinition = exports.command = void 0;\nconst common_types_1 = require(\"./common-types\");\nconst is_promise_1 = require(\"./is-promise\");\nconst middleware_1 = require(\"./middleware\");\nconst parse_command_1 = require(\"./parse-command\");\nconst path = require(\"path\");\nconst util_1 = require(\"util\");\nconst yargs_1 = require(\"./yargs\");\nconst requireDirectory = require(\"require-directory\");\nconst whichModule = require(\"which-module\");\nconst Parser = require(\"yargs-parser\");\nconst DEFAULT_MARKER = /(^\\*)|(^\\$0)/;\n// handles parsing positional arguments,\n// and populating argv with said positional\n// arguments.\nfunction command(yargs, usage, validation, globalMiddleware = []) {\n    const self = {};\n    let handlers = {};\n    let aliasMap = {};\n    let defaultCommand;\n    self.addHandler = function addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {\n        let aliases = [];\n        const middlewares = middleware_1.commandMiddlewareFactory(commandMiddleware);\n        handler = handler || (() => { });\n        if (Array.isArray(cmd)) {\n            aliases = cmd.slice(1);\n            cmd = cmd[0];\n        }\n        else if (isCommandHandlerDefinition(cmd)) {\n            let command = (Array.isArray(cmd.command) || typeof cmd.command === 'string') ? cmd.command : moduleName(cmd);\n            if (cmd.aliases)\n                command = [].concat(command).concat(cmd.aliases);\n            self.addHandler(command, extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);\n            return;\n        }\n        // allow a module to be provided instead of separate builder and handler\n        if (isCommandBuilderDefinition(builder)) {\n            self.addHandler([cmd].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);\n            return;\n        }\n        // parse positionals out of cmd string\n        const parsedCommand = parse_command_1.parseCommand(cmd);\n        // remove positional args from aliases only\n        aliases = aliases.map(alias => parse_command_1.parseCommand(alias).cmd);\n        // check for default and filter out '*''\n        let isDefault = false;\n        const parsedAliases = [parsedCommand.cmd].concat(aliases).filter((c) => {\n            if (DEFAULT_MARKER.test(c)) {\n                isDefault = true;\n                return false;\n            }\n            return true;\n        });\n        // standardize on $0 for default command.\n        if (parsedAliases.length === 0 && isDefault)\n            parsedAliases.push('$0');\n        // shift cmd and aliases after filtering out '*'\n        if (isDefault) {\n            parsedCommand.cmd = parsedAliases[0];\n            aliases = parsedAliases.slice(1);\n            cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);\n        }\n        // populate aliasMap\n        aliases.forEach((alias) => {\n            aliasMap[alias] = parsedCommand.cmd;\n        });\n        if (description !== false) {\n            usage.command(cmd, description, isDefault, aliases, deprecated);\n        }\n        handlers[parsedCommand.cmd] = {\n            original: cmd,\n            description,\n            handler,\n            builder: builder || {},\n            middlewares,\n            deprecated,\n            demanded: parsedCommand.demanded,\n            optional: parsedCommand.optional\n        };\n        if (isDefault)\n            defaultCommand = handlers[parsedCommand.cmd];\n    };\n    self.addDirectory = function addDirectory(dir, context, req, callerFile, opts) {\n        opts = opts || {};\n        // disable recursion to support nested directories of subcommands\n        if (typeof opts.recurse !== 'boolean')\n            opts.recurse = false;\n        // exclude 'json', 'coffee' from require-directory defaults\n        if (!Array.isArray(opts.extensions))\n            opts.extensions = ['js'];\n        // allow consumer to define their own visitor function\n        const parentVisit = typeof opts.visit === 'function' ? opts.visit : (o) => o;\n        // call addHandler via visitor function\n        opts.visit = function visit(obj, joined, filename) {\n            const visited = parentVisit(obj, joined, filename);\n            // allow consumer to skip modules with their own visitor\n            if (visited) {\n                // check for cyclic reference\n                // each command file path should only be seen once per execution\n                if (~context.files.indexOf(joined))\n                    return visited;\n                // keep track of visited files in context.files\n                context.files.push(joined);\n                self.addHandler(visited);\n            }\n            return visited;\n        };\n        requireDirectory({ require: req, filename: callerFile }, dir, opts);\n    };\n    // lookup module object from require()d command and derive name\n    // if module was not require()d and no name given, throw error\n    function moduleName(obj) {\n        const mod = whichModule(obj);\n        if (!mod)\n            throw new Error(`No command name given for module: ${util_1.inspect(obj)}`);\n        return commandFromFilename(mod.filename);\n    }\n    // derive command name from filename\n    function commandFromFilename(filename) {\n        return path.basename(filename, path.extname(filename));\n    }\n    function extractDesc({ describe, description, desc }) {\n        for (const test of [describe, description, desc]) {\n            if (typeof test === 'string' || test === false)\n                return test;\n            common_types_1.assertNotStrictEqual(test, true);\n        }\n        return false;\n    }\n    self.getCommands = () => Object.keys(handlers).concat(Object.keys(aliasMap));\n    self.getCommandHandlers = () => handlers;\n    self.hasDefaultCommand = () => !!defaultCommand;\n    self.runCommand = function runCommand(command, yargs, parsed, commandIndex) {\n        let aliases = parsed.aliases;\n        const commandHandler = handlers[command] || handlers[aliasMap[command]] || defaultCommand;\n        const currentContext = yargs.getContext();\n        let numFiles = currentContext.files.length;\n        const parentCommands = currentContext.commands.slice();\n        // what does yargs look like after the builder is run?\n        let innerArgv = parsed.argv;\n        let positionalMap = {};\n        if (command) {\n            currentContext.commands.push(command);\n            currentContext.fullCommands.push(commandHandler.original);\n        }\n        const builder = commandHandler.builder;\n        if (isCommandBuilderCallback(builder)) {\n            // a function can be provided, which builds\n            // up a yargs chain and possibly returns it.\n            const builderOutput = builder(yargs.reset(parsed.aliases));\n            const innerYargs = yargs_1.isYargsInstance(builderOutput) ? builderOutput : yargs;\n            if (shouldUpdateUsage(innerYargs)) {\n                innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n            }\n            innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n            aliases = innerYargs.parsed.aliases;\n        }\n        else if (isCommandBuilderOptionDefinitions(builder)) {\n            // as a short hand, an object can instead be provided, specifying\n            // the options that a command takes.\n            const innerYargs = yargs.reset(parsed.aliases);\n            if (shouldUpdateUsage(innerYargs)) {\n                innerYargs.getUsageInstance().usage(usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);\n            }\n            Object.keys(commandHandler.builder).forEach((key) => {\n                innerYargs.option(key, builder[key]);\n            });\n            innerArgv = innerYargs._parseArgs(null, null, true, commandIndex);\n            aliases = innerYargs.parsed.aliases;\n        }\n        if (!yargs._hasOutput()) {\n            positionalMap = populatePositionals(commandHandler, innerArgv, currentContext);\n        }\n        const middlewares = globalMiddleware.slice(0).concat(commandHandler.middlewares);\n        middleware_1.applyMiddleware(innerArgv, yargs, middlewares, true);\n        // we apply validation post-hoc, so that custom\n        // checks get passed populated positional arguments.\n        if (!yargs._hasOutput()) {\n            yargs._runValidation(innerArgv, aliases, positionalMap, yargs.parsed.error, !command);\n        }\n        if (commandHandler.handler && !yargs._hasOutput()) {\n            yargs._setHasOutput();\n            // to simplify the parsing of positionals in commands,\n            // we temporarily populate '--' rather than _, with arguments\n            const populateDoubleDash = !!yargs.getOptions().configuration['populate--'];\n            if (!populateDoubleDash)\n                yargs._copyDoubleDash(innerArgv);\n            innerArgv = middleware_1.applyMiddleware(innerArgv, yargs, middlewares, false);\n            let handlerResult;\n            if (is_promise_1.isPromise(innerArgv)) {\n                handlerResult = innerArgv.then(argv => commandHandler.handler(argv));\n            }\n            else {\n                handlerResult = commandHandler.handler(innerArgv);\n            }\n            const handlerFinishCommand = yargs.getHandlerFinishCommand();\n            if (is_promise_1.isPromise(handlerResult)) {\n                yargs.getUsageInstance().cacheHelpMessage();\n                handlerResult\n                    .then(value => {\n                    if (handlerFinishCommand) {\n                        handlerFinishCommand(value);\n                    }\n                })\n                    .catch(error => {\n                    try {\n                        yargs.getUsageInstance().fail(null, error);\n                    }\n                    catch (err) {\n                        // fail's throwing would cause an unhandled rejection.\n                    }\n                })\n                    .then(() => {\n                    yargs.getUsageInstance().clearCachedHelpMessage();\n                });\n            }\n            else {\n                if (handlerFinishCommand) {\n                    handlerFinishCommand(handlerResult);\n                }\n            }\n        }\n        if (command) {\n            currentContext.commands.pop();\n            currentContext.fullCommands.pop();\n        }\n        numFiles = currentContext.files.length - numFiles;\n        if (numFiles > 0)\n            currentContext.files.splice(numFiles * -1, numFiles);\n        return innerArgv;\n    };\n    function shouldUpdateUsage(yargs) {\n        return !yargs.getUsageInstance().getUsageDisabled() &&\n            yargs.getUsageInstance().getUsage().length === 0;\n    }\n    function usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {\n        const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, '').trim() : commandHandler.original;\n        const pc = parentCommands.filter((c) => { return !DEFAULT_MARKER.test(c); });\n        pc.push(c);\n        return `$0 ${pc.join(' ')}`;\n    }\n    self.runDefaultBuilderOn = function (yargs) {\n        common_types_1.assertNotStrictEqual(defaultCommand, undefined);\n        if (shouldUpdateUsage(yargs)) {\n            // build the root-level command string from the default string.\n            const commandString = DEFAULT_MARKER.test(defaultCommand.original)\n                ? defaultCommand.original : defaultCommand.original.replace(/^[^[\\]<>]*/, '$0 ');\n            yargs.getUsageInstance().usage(commandString, defaultCommand.description);\n        }\n        const builder = defaultCommand.builder;\n        if (isCommandBuilderCallback(builder)) {\n            builder(yargs);\n        }\n        else {\n            Object.keys(builder).forEach((key) => {\n                yargs.option(key, builder[key]);\n            });\n        }\n    };\n    // transcribe all positional arguments \"command <foo> <bar> [apple]\"\n    // onto argv.\n    function populatePositionals(commandHandler, argv, context) {\n        argv._ = argv._.slice(context.commands.length); // nuke the current commands\n        const demanded = commandHandler.demanded.slice(0);\n        const optional = commandHandler.optional.slice(0);\n        const positionalMap = {};\n        validation.positionalCount(demanded.length, argv._.length);\n        while (demanded.length) {\n            const demand = demanded.shift();\n            populatePositional(demand, argv, positionalMap);\n        }\n        while (optional.length) {\n            const maybe = optional.shift();\n            populatePositional(maybe, argv, positionalMap);\n        }\n        argv._ = context.commands.concat(argv._);\n        postProcessPositionals(argv, positionalMap, self.cmdToParseOptions(commandHandler.original));\n        return positionalMap;\n    }\n    function populatePositional(positional, argv, positionalMap) {\n        const cmd = positional.cmd[0];\n        if (positional.variadic) {\n            positionalMap[cmd] = argv._.splice(0).map(String);\n        }\n        else {\n            if (argv._.length)\n                positionalMap[cmd] = [String(argv._.shift())];\n        }\n    }\n    // we run yargs-parser against the positional arguments\n    // applying the same parsing logic used for flags.\n    function postProcessPositionals(argv, positionalMap, parseOptions) {\n        // combine the parsing hints we've inferred from the command\n        // string with explicitly configured parsing hints.\n        const options = Object.assign({}, yargs.getOptions());\n        options.default = Object.assign(parseOptions.default, options.default);\n        for (const key of Object.keys(parseOptions.alias)) {\n            options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);\n        }\n        options.array = options.array.concat(parseOptions.array);\n        delete options.config; //  don't load config when processing positionals.\n        const unparsed = [];\n        Object.keys(positionalMap).forEach((key) => {\n            positionalMap[key].map((value) => {\n                if (options.configuration['unknown-options-as-args'])\n                    options.key[key] = true;\n                unparsed.push(`--${key}`);\n                unparsed.push(value);\n            });\n        });\n        // short-circuit parse.\n        if (!unparsed.length)\n            return;\n        const config = Object.assign({}, options.configuration, {\n            'populate--': true\n        });\n        const parsed = Parser.detailed(unparsed, Object.assign({}, options, {\n            configuration: config\n        }));\n        if (parsed.error) {\n            yargs.getUsageInstance().fail(parsed.error.message, parsed.error);\n        }\n        else {\n            // only copy over positional keys (don't overwrite\n            // flag arguments that were already parsed).\n            const positionalKeys = Object.keys(positionalMap);\n            Object.keys(positionalMap).forEach((key) => {\n                positionalKeys.push(...parsed.aliases[key]);\n            });\n            Object.keys(parsed.argv).forEach((key) => {\n                if (positionalKeys.indexOf(key) !== -1) {\n                    // any new aliases need to be placed in positionalMap, which\n                    // is used for validation.\n                    if (!positionalMap[key])\n                        positionalMap[key] = parsed.argv[key];\n                    argv[key] = parsed.argv[key];\n                }\n            });\n        }\n    }\n    self.cmdToParseOptions = function (cmdString) {\n        const parseOptions = {\n            array: [],\n            default: {},\n            alias: {},\n            demand: {}\n        };\n        const parsed = parse_command_1.parseCommand(cmdString);\n        parsed.demanded.forEach((d) => {\n            const [cmd, ...aliases] = d.cmd;\n            if (d.variadic) {\n                parseOptions.array.push(cmd);\n                parseOptions.default[cmd] = [];\n            }\n            parseOptions.alias[cmd] = aliases;\n            parseOptions.demand[cmd] = true;\n        });\n        parsed.optional.forEach((o) => {\n            const [cmd, ...aliases] = o.cmd;\n            if (o.variadic) {\n                parseOptions.array.push(cmd);\n                parseOptions.default[cmd] = [];\n            }\n            parseOptions.alias[cmd] = aliases;\n        });\n        return parseOptions;\n    };\n    self.reset = () => {\n        handlers = {};\n        aliasMap = {};\n        defaultCommand = undefined;\n        return self;\n    };\n    // used by yargs.parse() to freeze\n    // the state of commands such that\n    // we can apply .parse() multiple times\n    // with the same yargs instance.\n    const frozens = [];\n    self.freeze = () => {\n        frozens.push({\n            handlers,\n            aliasMap,\n            defaultCommand\n        });\n    };\n    self.unfreeze = () => {\n        const frozen = frozens.pop();\n        common_types_1.assertNotStrictEqual(frozen, undefined);\n        ({\n            handlers,\n            aliasMap,\n            defaultCommand\n        } = frozen);\n    };\n    return self;\n}\nexports.command = command;\nfunction isCommandHandlerDefinition(cmd) {\n    return typeof cmd === 'object';\n}\nexports.isCommandHandlerDefinition = isCommandHandlerDefinition;\nfunction isCommandBuilderDefinition(builder) {\n    return typeof builder === 'object' &&\n        !!builder.builder &&\n        typeof builder.handler === 'function';\n}\nexports.isCommandBuilderDefinition = isCommandBuilderDefinition;\nfunction isCommandBuilderCallback(builder) {\n    return typeof builder === 'function';\n}\nexports.isCommandBuilderCallback = isCommandBuilderCallback;\nfunction isCommandBuilderOptionDefinitions(builder) {\n    return typeof builder === 'object';\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.objectKeys = exports.assertSingleKey = exports.assertNotStrictEqual = void 0;\nconst assert_1 = require(\"assert\");\n/**\n * Typing wrapper around assert.notStrictEqual()\n */\nfunction assertNotStrictEqual(actual, expected, message) {\n    assert_1.notStrictEqual(actual, expected, message);\n}\nexports.assertNotStrictEqual = assertNotStrictEqual;\n/**\n * Asserts actual is a single key, not a key array or a key map.\n */\nfunction assertSingleKey(actual) {\n    assert_1.strictEqual(typeof actual, 'string');\n}\nexports.assertSingleKey = assertSingleKey;\n/**\n * Typing wrapper around Object.keys()\n */\nfunction objectKeys(object) {\n    return Object.keys(object);\n}\nexports.objectKeys = objectKeys;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isPromise = void 0;\nfunction isPromise(maybePromise) {\n    return !!maybePromise &&\n        !!maybePromise.then &&\n        (typeof maybePromise.then === 'function');\n}\nexports.isPromise = isPromise;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyMiddleware = exports.commandMiddlewareFactory = exports.globalMiddlewareFactory = void 0;\nconst argsert_1 = require(\"./argsert\");\nconst is_promise_1 = require(\"./is-promise\");\nfunction globalMiddlewareFactory(globalMiddleware, context) {\n    return function (callback, applyBeforeValidation = false) {\n        argsert_1.argsert('<array|function> [boolean]', [callback, applyBeforeValidation], arguments.length);\n        if (Array.isArray(callback)) {\n            for (let i = 0; i < callback.length; i++) {\n                if (typeof callback[i] !== 'function') {\n                    throw Error('middleware must be a function');\n                }\n                callback[i].applyBeforeValidation = applyBeforeValidation;\n            }\n            Array.prototype.push.apply(globalMiddleware, callback);\n        }\n        else if (typeof callback === 'function') {\n            callback.applyBeforeValidation = applyBeforeValidation;\n            globalMiddleware.push(callback);\n        }\n        return context;\n    };\n}\nexports.globalMiddlewareFactory = globalMiddlewareFactory;\nfunction commandMiddlewareFactory(commandMiddleware) {\n    if (!commandMiddleware)\n        return [];\n    return commandMiddleware.map(middleware => {\n        middleware.applyBeforeValidation = false;\n        return middleware;\n    });\n}\nexports.commandMiddlewareFactory = commandMiddlewareFactory;\nfunction applyMiddleware(argv, yargs, middlewares, beforeValidation) {\n    const beforeValidationError = new Error('middleware cannot return a promise when applyBeforeValidation is true');\n    return middlewares\n        .reduce((acc, middleware) => {\n        if (middleware.applyBeforeValidation !== beforeValidation) {\n            return acc;\n        }\n        if (is_promise_1.isPromise(acc)) {\n            return acc\n                .then(initialObj => Promise.all([initialObj, middleware(initialObj, yargs)]))\n                .then(([initialObj, middlewareObj]) => Object.assign(initialObj, middlewareObj));\n        }\n        else {\n            const result = middleware(acc, yargs);\n            if (beforeValidation && is_promise_1.isPromise(result))\n                throw beforeValidationError;\n            return is_promise_1.isPromise(result)\n                ? result.then(middlewareObj => Object.assign(acc, middlewareObj))\n                : Object.assign(acc, result);\n        }\n    }, argv);\n}\nexports.applyMiddleware = applyMiddleware;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.argsert = void 0;\nconst yerror_1 = require(\"./yerror\");\nconst parse_command_1 = require(\"./parse-command\");\nconst positionName = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth'];\nfunction argsert(arg1, arg2, arg3) {\n    function parseArgs() {\n        return typeof arg1 === 'object'\n            ? [{ demanded: [], optional: [] }, arg1, arg2]\n            : [parse_command_1.parseCommand(`cmd ${arg1}`), arg2, arg3];\n    }\n    // TODO: should this eventually raise an exception.\n    try {\n        // preface the argument description with \"cmd\", so\n        // that we can run it through yargs' command parser.\n        let position = 0;\n        let [parsed, callerArguments, length] = parseArgs();\n        const args = [].slice.call(callerArguments);\n        while (args.length && args[args.length - 1] === undefined)\n            args.pop();\n        length = length || args.length;\n        if (length < parsed.demanded.length) {\n            throw new yerror_1.YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);\n        }\n        const totalCommands = parsed.demanded.length + parsed.optional.length;\n        if (length > totalCommands) {\n            throw new yerror_1.YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);\n        }\n        parsed.demanded.forEach((demanded) => {\n            const arg = args.shift();\n            const observedType = guessType(arg);\n            const matchingTypes = demanded.cmd.filter(type => type === observedType || type === '*');\n            if (matchingTypes.length === 0)\n                argumentTypeError(observedType, demanded.cmd, position);\n            position += 1;\n        });\n        parsed.optional.forEach((optional) => {\n            if (args.length === 0)\n                return;\n            const arg = args.shift();\n            const observedType = guessType(arg);\n            const matchingTypes = optional.cmd.filter(type => type === observedType || type === '*');\n            if (matchingTypes.length === 0)\n                argumentTypeError(observedType, optional.cmd, position);\n            position += 1;\n        });\n    }\n    catch (err) {\n        console.warn(err.stack);\n    }\n}\nexports.argsert = argsert;\nfunction guessType(arg) {\n    if (Array.isArray(arg)) {\n        return 'array';\n    }\n    else if (arg === null) {\n        return 'null';\n    }\n    return typeof arg;\n}\nfunction argumentTypeError(observedType, allowedTypes, position) {\n    throw new yerror_1.YError(`Invalid ${positionName[position] || 'manyith'} argument. Expected ${allowedTypes.join(' or ')} but received ${observedType}.`);\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.YError = void 0;\nclass YError extends Error {\n    constructor(msg) {\n        super(msg || 'yargs error');\n        this.name = 'YError';\n        Error.captureStackTrace(this, YError);\n    }\n}\nexports.YError = YError;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseCommand = void 0;\nfunction parseCommand(cmd) {\n    const extraSpacesStrippedCommand = cmd.replace(/\\s{2,}/g, ' ');\n    const splitCommand = extraSpacesStrippedCommand.split(/\\s+(?![^[]*]|[^<]*>)/);\n    const bregex = /\\.*[\\][<>]/g;\n    const firstCommand = splitCommand.shift();\n    if (!firstCommand)\n        throw new Error(`No command found in: ${cmd}`);\n    const parsedCommand = {\n        cmd: firstCommand.replace(bregex, ''),\n        demanded: [],\n        optional: []\n    };\n    splitCommand.forEach((cmd, i) => {\n        let variadic = false;\n        cmd = cmd.replace(/\\s/g, '');\n        if (/\\.+[\\]>]/.test(cmd) && i === splitCommand.length - 1)\n            variadic = true;\n        if (/^\\[/.test(cmd)) {\n            parsedCommand.optional.push({\n                cmd: cmd.replace(bregex, '').split('|'),\n                variadic\n            });\n        }\n        else {\n            parsedCommand.demanded.push({\n                cmd: cmd.replace(bregex, '').split('|'),\n                variadic\n            });\n        }\n    });\n    return parsedCommand;\n}\nexports.parseCommand = parseCommand;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.usage = void 0;\n// this file handles outputting usage instructions,\n// failures, etc. keeps logging in one place.\nconst common_types_1 = require(\"./common-types\");\nconst obj_filter_1 = require(\"./obj-filter\");\nconst path = require(\"path\");\nconst yerror_1 = require(\"./yerror\");\nconst decamelize = require(\"decamelize\");\nconst setBlocking = require(\"set-blocking\");\nconst stringWidth = require(\"string-width\");\nfunction usage(yargs, y18n) {\n    const __ = y18n.__;\n    const self = {};\n    // methods for ouputting/building failure message.\n    const fails = [];\n    self.failFn = function failFn(f) {\n        fails.push(f);\n    };\n    let failMessage = null;\n    let showHelpOnFail = true;\n    self.showHelpOnFail = function showHelpOnFailFn(arg1 = true, arg2) {\n        function parseFunctionArgs() {\n            return typeof arg1 === 'string' ? [true, arg1] : [arg1, arg2];\n        }\n        const [enabled, message] = parseFunctionArgs();\n        failMessage = message;\n        showHelpOnFail = enabled;\n        return self;\n    };\n    let failureOutput = false;\n    self.fail = function fail(msg, err) {\n        const logger = yargs._getLoggerInstance();\n        if (fails.length) {\n            for (let i = fails.length - 1; i >= 0; --i) {\n                fails[i](msg, err, self);\n            }\n        }\n        else {\n            if (yargs.getExitProcess())\n                setBlocking(true);\n            // don't output failure message more than once\n            if (!failureOutput) {\n                failureOutput = true;\n                if (showHelpOnFail) {\n                    yargs.showHelp('error');\n                    logger.error();\n                }\n                if (msg || err)\n                    logger.error(msg || err);\n                if (failMessage) {\n                    if (msg || err)\n                        logger.error('');\n                    logger.error(failMessage);\n                }\n            }\n            err = err || new yerror_1.YError(msg);\n            if (yargs.getExitProcess()) {\n                return yargs.exit(1);\n            }\n            else if (yargs._hasParseCallback()) {\n                return yargs.exit(1, err);\n            }\n            else {\n                throw err;\n            }\n        }\n    };\n    // methods for ouputting/building help (usage) message.\n    let usages = [];\n    let usageDisabled = false;\n    self.usage = (msg, description) => {\n        if (msg === null) {\n            usageDisabled = true;\n            usages = [];\n            return self;\n        }\n        usageDisabled = false;\n        usages.push([msg, description || '']);\n        return self;\n    };\n    self.getUsage = () => {\n        return usages;\n    };\n    self.getUsageDisabled = () => {\n        return usageDisabled;\n    };\n    self.getPositionalGroupName = () => {\n        return __('Positionals:');\n    };\n    let examples = [];\n    self.example = (cmd, description) => {\n        examples.push([cmd, description || '']);\n    };\n    let commands = [];\n    self.command = function command(cmd, description, isDefault, aliases, deprecated = false) {\n        // the last default wins, so cancel out any previously set default\n        if (isDefault) {\n            commands = commands.map((cmdArray) => {\n                cmdArray[2] = false;\n                return cmdArray;\n            });\n        }\n        commands.push([cmd, description || '', isDefault, aliases, deprecated]);\n    };\n    self.getCommands = () => commands;\n    let descriptions = {};\n    self.describe = function describe(keyOrKeys, desc) {\n        if (Array.isArray(keyOrKeys)) {\n            keyOrKeys.forEach((k) => {\n                self.describe(k, desc);\n            });\n        }\n        else if (typeof keyOrKeys === 'object') {\n            Object.keys(keyOrKeys).forEach((k) => {\n                self.describe(k, keyOrKeys[k]);\n            });\n        }\n        else {\n            descriptions[keyOrKeys] = desc;\n        }\n    };\n    self.getDescriptions = () => descriptions;\n    let epilogs = [];\n    self.epilog = (msg) => {\n        epilogs.push(msg);\n    };\n    let wrapSet = false;\n    let wrap;\n    self.wrap = (cols) => {\n        wrapSet = true;\n        wrap = cols;\n    };\n    function getWrap() {\n        if (!wrapSet) {\n            wrap = windowWidth();\n            wrapSet = true;\n        }\n        return wrap;\n    }\n    const deferY18nLookupPrefix = '__yargsString__:';\n    self.deferY18nLookup = str => deferY18nLookupPrefix + str;\n    self.help = function help() {\n        if (cachedHelpMessage)\n            return cachedHelpMessage;\n        normalizeAliases();\n        // handle old demanded API\n        const base$0 = yargs.customScriptName ? yargs.$0 : path.basename(yargs.$0);\n        const demandedOptions = yargs.getDemandedOptions();\n        const demandedCommands = yargs.getDemandedCommands();\n        const deprecatedOptions = yargs.getDeprecatedOptions();\n        const groups = yargs.getGroups();\n        const options = yargs.getOptions();\n        let keys = [];\n        keys = keys.concat(Object.keys(descriptions));\n        keys = keys.concat(Object.keys(demandedOptions));\n        keys = keys.concat(Object.keys(demandedCommands));\n        keys = keys.concat(Object.keys(options.default));\n        keys = keys.filter(filterHiddenOptions);\n        keys = Object.keys(keys.reduce((acc, key) => {\n            if (key !== '_')\n                acc[key] = true;\n            return acc;\n        }, {}));\n        const theWrap = getWrap();\n        const ui = require('cliui')({\n            width: theWrap,\n            wrap: !!theWrap\n        });\n        // the usage string.\n        if (!usageDisabled) {\n            if (usages.length) {\n                // user-defined usage.\n                usages.forEach((usage) => {\n                    ui.div(`${usage[0].replace(/\\$0/g, base$0)}`);\n                    if (usage[1]) {\n                        ui.div({ text: `${usage[1]}`, padding: [1, 0, 0, 0] });\n                    }\n                });\n                ui.div();\n            }\n            else if (commands.length) {\n                let u = null;\n                // demonstrate how commands are used.\n                if (demandedCommands._) {\n                    u = `${base$0} <${__('command')}>\\n`;\n                }\n                else {\n                    u = `${base$0} [${__('command')}]\\n`;\n                }\n                ui.div(`${u}`);\n            }\n        }\n        // your application's commands, i.e., non-option\n        // arguments populated in '_'.\n        if (commands.length) {\n            ui.div(__('Commands:'));\n            const context = yargs.getContext();\n            const parentCommands = context.commands.length ? `${context.commands.join(' ')} ` : '';\n            if (yargs.getParserConfiguration()['sort-commands'] === true) {\n                commands = commands.sort((a, b) => a[0].localeCompare(b[0]));\n            }\n            commands.forEach((command) => {\n                const commandString = `${base$0} ${parentCommands}${command[0].replace(/^\\$0 ?/, '')}`; // drop $0 from default commands.\n                ui.span({\n                    text: commandString,\n                    padding: [0, 2, 0, 2],\n                    width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4\n                }, { text: command[1] });\n                const hints = [];\n                if (command[2])\n                    hints.push(`[${__('default')}]`);\n                if (command[3] && command[3].length) {\n                    hints.push(`[${__('aliases:')} ${command[3].join(', ')}]`);\n                }\n                if (command[4]) {\n                    if (typeof command[4] === 'string') {\n                        hints.push(`[${__('deprecated: %s', command[4])}]`);\n                    }\n                    else {\n                        hints.push(`[${__('deprecated')}]`);\n                    }\n                }\n                if (hints.length) {\n                    ui.div({ text: hints.join(' '), padding: [0, 0, 0, 2], align: 'right' });\n                }\n                else {\n                    ui.div();\n                }\n            });\n            ui.div();\n        }\n        // perform some cleanup on the keys array, making it\n        // only include top-level keys not their aliases.\n        const aliasKeys = (Object.keys(options.alias) || [])\n            .concat(Object.keys(yargs.parsed.newAliases) || []);\n        keys = keys.filter(key => !yargs.parsed.newAliases[key] && aliasKeys.every(alias => (options.alias[alias] || []).indexOf(key) === -1));\n        // populate 'Options:' group with any keys that have not\n        // explicitly had a group set.\n        const defaultGroup = __('Options:');\n        if (!groups[defaultGroup])\n            groups[defaultGroup] = [];\n        addUngroupedKeys(keys, options.alias, groups, defaultGroup);\n        // display 'Options:' table along with any custom tables:\n        Object.keys(groups).forEach((groupName) => {\n            if (!groups[groupName].length)\n                return;\n            // if we've grouped the key 'f', but 'f' aliases 'foobar',\n            // normalizedKeys should contain only 'foobar'.\n            const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map((key) => {\n                if (~aliasKeys.indexOf(key))\n                    return key;\n                for (let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== undefined; i++) {\n                    if (~(options.alias[aliasKey] || []).indexOf(key))\n                        return aliasKey;\n                }\n                return key;\n            });\n            if (normalizedKeys.length < 1)\n                return;\n            ui.div(groupName);\n            // actually generate the switches string --foo, -f, --bar.\n            const switches = normalizedKeys.reduce((acc, key) => {\n                acc[key] = [key].concat(options.alias[key] || [])\n                    .map(sw => {\n                    // for the special positional group don't\n                    // add '--' or '-' prefix.\n                    if (groupName === self.getPositionalGroupName())\n                        return sw;\n                    else {\n                        return (\n                        // matches yargs-parser logic in which single-digits\n                        // aliases declared with a boolean type are now valid\n                        /^[0-9]$/.test(sw)\n                            ? ~options.boolean.indexOf(key) ? '-' : '--'\n                            : sw.length > 1 ? '--' : '-') + sw;\n                    }\n                })\n                    .join(', ');\n                return acc;\n            }, {});\n            normalizedKeys.forEach((key) => {\n                const kswitch = switches[key];\n                let desc = descriptions[key] || '';\n                let type = null;\n                if (~desc.lastIndexOf(deferY18nLookupPrefix))\n                    desc = __(desc.substring(deferY18nLookupPrefix.length));\n                if (~options.boolean.indexOf(key))\n                    type = `[${__('boolean')}]`;\n                if (~options.count.indexOf(key))\n                    type = `[${__('count')}]`;\n                if (~options.string.indexOf(key))\n                    type = `[${__('string')}]`;\n                if (~options.normalize.indexOf(key))\n                    type = `[${__('string')}]`;\n                if (~options.array.indexOf(key))\n                    type = `[${__('array')}]`;\n                if (~options.number.indexOf(key))\n                    type = `[${__('number')}]`;\n                const deprecatedExtra = (deprecated) => typeof deprecated === 'string'\n                    ? `[${__('deprecated: %s', deprecated)}]`\n                    : `[${__('deprecated')}]`;\n                const extra = [\n                    (key in deprecatedOptions) ? deprecatedExtra(deprecatedOptions[key]) : null,\n                    type,\n                    (key in demandedOptions) ? `[${__('required')}]` : null,\n                    options.choices && options.choices[key] ? `[${__('choices:')} ${self.stringifiedValues(options.choices[key])}]` : null,\n                    defaultString(options.default[key], options.defaultDescription[key])\n                ].filter(Boolean).join(' ');\n                ui.span({ text: kswitch, padding: [0, 2, 0, 2], width: maxWidth(switches, theWrap) + 4 }, desc);\n                if (extra)\n                    ui.div({ text: extra, padding: [0, 0, 0, 2], align: 'right' });\n                else\n                    ui.div();\n            });\n            ui.div();\n        });\n        // describe some common use-cases for your application.\n        if (examples.length) {\n            ui.div(__('Examples:'));\n            examples.forEach((example) => {\n                example[0] = example[0].replace(/\\$0/g, base$0);\n            });\n            examples.forEach((example) => {\n                if (example[1] === '') {\n                    ui.div({\n                        text: example[0],\n                        padding: [0, 2, 0, 2]\n                    });\n                }\n                else {\n                    ui.div({\n                        text: example[0],\n                        padding: [0, 2, 0, 2],\n                        width: maxWidth(examples, theWrap) + 4\n                    }, {\n                        text: example[1]\n                    });\n                }\n            });\n            ui.div();\n        }\n        // the usage string.\n        if (epilogs.length > 0) {\n            const e = epilogs.map(epilog => epilog.replace(/\\$0/g, base$0)).join('\\n');\n            ui.div(`${e}\\n`);\n        }\n        // Remove the trailing white spaces\n        return ui.toString().replace(/\\s*$/, '');\n    };\n    // return the maximum width of a string\n    // in the left-hand column of a table.\n    function maxWidth(table, theWrap, modifier) {\n        let width = 0;\n        // table might be of the form [leftColumn],\n        // or {key: leftColumn}\n        if (!Array.isArray(table)) {\n            table = Object.values(table).map(v => [v]);\n        }\n        table.forEach((v) => {\n            width = Math.max(stringWidth(modifier ? `${modifier} ${v[0]}` : v[0]), width);\n        });\n        // if we've enabled 'wrap' we should limit\n        // the max-width of the left-column.\n        if (theWrap)\n            width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));\n        return width;\n    }\n    // make sure any options set for aliases,\n    // are copied to the keys being aliased.\n    function normalizeAliases() {\n        // handle old demanded API\n        const demandedOptions = yargs.getDemandedOptions();\n        const options = yargs.getOptions();\n        (Object.keys(options.alias) || []).forEach((key) => {\n            options.alias[key].forEach((alias) => {\n                // copy descriptions.\n                if (descriptions[alias])\n                    self.describe(key, descriptions[alias]);\n                // copy demanded.\n                if (alias in demandedOptions)\n                    yargs.demandOption(key, demandedOptions[alias]);\n                // type messages.\n                if (~options.boolean.indexOf(alias))\n                    yargs.boolean(key);\n                if (~options.count.indexOf(alias))\n                    yargs.count(key);\n                if (~options.string.indexOf(alias))\n                    yargs.string(key);\n                if (~options.normalize.indexOf(alias))\n                    yargs.normalize(key);\n                if (~options.array.indexOf(alias))\n                    yargs.array(key);\n                if (~options.number.indexOf(alias))\n                    yargs.number(key);\n            });\n        });\n    }\n    // if yargs is executing an async handler, we take a snapshot of the\n    // help message to display on failure:\n    let cachedHelpMessage;\n    self.cacheHelpMessage = function () {\n        cachedHelpMessage = this.help();\n    };\n    // however this snapshot must be cleared afterwards\n    // not to be be used by next calls to parse\n    self.clearCachedHelpMessage = function () {\n        cachedHelpMessage = undefined;\n    };\n    // given a set of keys, place any keys that are\n    // ungrouped under the 'Options:' grouping.\n    function addUngroupedKeys(keys, aliases, groups, defaultGroup) {\n        let groupedKeys = [];\n        let toCheck = null;\n        Object.keys(groups).forEach((group) => {\n            groupedKeys = groupedKeys.concat(groups[group]);\n        });\n        keys.forEach((key) => {\n            toCheck = [key].concat(aliases[key]);\n            if (!toCheck.some(k => groupedKeys.indexOf(k) !== -1)) {\n                groups[defaultGroup].push(key);\n            }\n        });\n        return groupedKeys;\n    }\n    function filterHiddenOptions(key) {\n        return yargs.getOptions().hiddenOptions.indexOf(key) < 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt];\n    }\n    self.showHelp = (level) => {\n        const logger = yargs._getLoggerInstance();\n        if (!level)\n            level = 'error';\n        const emit = typeof level === 'function' ? level : logger[level];\n        emit(self.help());\n    };\n    self.functionDescription = (fn) => {\n        const description = fn.name ? decamelize(fn.name, '-') : __('generated-value');\n        return ['(', description, ')'].join('');\n    };\n    self.stringifiedValues = function stringifiedValues(values, separator) {\n        let string = '';\n        const sep = separator || ', ';\n        const array = [].concat(values);\n        if (!values || !array.length)\n            return string;\n        array.forEach((value) => {\n            if (string.length)\n                string += sep;\n            string += JSON.stringify(value);\n        });\n        return string;\n    };\n    // format the default-value-string displayed in\n    // the right-hand column.\n    function defaultString(value, defaultDescription) {\n        let string = `[${__('default:')} `;\n        if (value === undefined && !defaultDescription)\n            return null;\n        if (defaultDescription) {\n            string += defaultDescription;\n        }\n        else {\n            switch (typeof value) {\n                case 'string':\n                    string += `\"${value}\"`;\n                    break;\n                case 'object':\n                    string += JSON.stringify(value);\n                    break;\n                default:\n                    string += value;\n            }\n        }\n        return `${string}]`;\n    }\n    // guess the width of the console window, max-width 80.\n    function windowWidth() {\n        const maxWidth = 80;\n        // CI is not a TTY\n        /* c8 ignore next 2 */\n        if (typeof process === 'object' && process.stdout && process.stdout.columns) {\n            return Math.min(maxWidth, process.stdout.columns);\n        }\n        else {\n            return maxWidth;\n        }\n    }\n    // logic for displaying application version.\n    let version = null;\n    self.version = (ver) => {\n        version = ver;\n    };\n    self.showVersion = () => {\n        const logger = yargs._getLoggerInstance();\n        logger.log(version);\n    };\n    self.reset = function reset(localLookup) {\n        // do not reset wrap here\n        // do not reset fails here\n        failMessage = null;\n        failureOutput = false;\n        usages = [];\n        usageDisabled = false;\n        epilogs = [];\n        examples = [];\n        commands = [];\n        descriptions = obj_filter_1.objFilter(descriptions, k => !localLookup[k]);\n        return self;\n    };\n    const frozens = [];\n    self.freeze = function freeze() {\n        frozens.push({\n            failMessage,\n            failureOutput,\n            usages,\n            usageDisabled,\n            epilogs,\n            examples,\n            commands,\n            descriptions\n        });\n    };\n    self.unfreeze = function unfreeze() {\n        const frozen = frozens.pop();\n        common_types_1.assertNotStrictEqual(frozen, undefined);\n        ({\n            failMessage,\n            failureOutput,\n            usages,\n            usageDisabled,\n            epilogs,\n            examples,\n            commands,\n            descriptions\n        } = frozen);\n    };\n    return self;\n}\nexports.usage = usage;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.objFilter = void 0;\nconst common_types_1 = require(\"./common-types\");\nfunction objFilter(original = {}, filter = () => true) {\n    const obj = {};\n    common_types_1.objectKeys(original).forEach((key) => {\n        if (filter(key, original[key])) {\n            obj[key] = original[key];\n        }\n    });\n    return obj;\n}\nexports.objFilter = objFilter;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.completion = void 0;\nconst command_1 = require(\"./command\");\nconst templates = require(\"./completion-templates\");\nconst is_promise_1 = require(\"./is-promise\");\nconst parse_command_1 = require(\"./parse-command\");\nconst path = require(\"path\");\nconst common_types_1 = require(\"./common-types\");\n// add bash completions to your\n//  yargs-powered applications.\nfunction completion(yargs, usage, command) {\n    const self = {\n        completionKey: 'get-yargs-completions'\n    };\n    let aliases;\n    self.setParsed = function setParsed(parsed) {\n        aliases = parsed.aliases;\n    };\n    const zshShell = (process.env.SHELL && process.env.SHELL.indexOf('zsh') !== -1) ||\n        (process.env.ZSH_NAME && process.env.ZSH_NAME.indexOf('zsh') !== -1);\n    // get a list of completion commands.\n    // 'args' is the array of strings from the line to be completed\n    self.getCompletion = function getCompletion(args, done) {\n        const completions = [];\n        const current = args.length ? args[args.length - 1] : '';\n        const argv = yargs.parse(args, true);\n        const parentCommands = yargs.getContext().commands;\n        // a custom completion function can be provided\n        // to completion().\n        function runCompletionFunction(argv) {\n            common_types_1.assertNotStrictEqual(completionFunction, null);\n            if (isSyncCompletionFunction(completionFunction)) {\n                const result = completionFunction(current, argv);\n                // promise based completion function.\n                if (is_promise_1.isPromise(result)) {\n                    return result.then((list) => {\n                        process.nextTick(() => { done(list); });\n                    }).catch((err) => {\n                        process.nextTick(() => { throw err; });\n                    });\n                }\n                // synchronous completion function.\n                return done(result);\n            }\n            else {\n                // asynchronous completion function\n                return completionFunction(current, argv, (completions) => {\n                    done(completions);\n                });\n            }\n        }\n        if (completionFunction) {\n            return is_promise_1.isPromise(argv) ? argv.then(runCompletionFunction) : runCompletionFunction(argv);\n        }\n        const handlers = command.getCommandHandlers();\n        for (let i = 0, ii = args.length; i < ii; ++i) {\n            if (handlers[args[i]] && handlers[args[i]].builder) {\n                const builder = handlers[args[i]].builder;\n                if (command_1.isCommandBuilderCallback(builder)) {\n                    const y = yargs.reset();\n                    builder(y);\n                    return y.argv;\n                }\n            }\n        }\n        if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current) {\n            usage.getCommands().forEach((usageCommand) => {\n                const commandName = parse_command_1.parseCommand(usageCommand[0]).cmd;\n                if (args.indexOf(commandName) === -1) {\n                    if (!zshShell) {\n                        completions.push(commandName);\n                    }\n                    else {\n                        const desc = usageCommand[1] || '';\n                        completions.push(commandName.replace(/:/g, '\\\\:') + ':' + desc);\n                    }\n                }\n            });\n        }\n        if (current.match(/^-/) || (current === '' && completions.length === 0)) {\n            const descs = usage.getDescriptions();\n            const options = yargs.getOptions();\n            Object.keys(options.key).forEach((key) => {\n                const negable = !!options.configuration['boolean-negation'] && options.boolean.includes(key);\n                // If the key and its aliases aren't in 'args', add the key to 'completions'\n                let keyAndAliases = [key].concat(aliases[key] || []);\n                if (negable)\n                    keyAndAliases = keyAndAliases.concat(keyAndAliases.map(key => `no-${key}`));\n                function completeOptionKey(key) {\n                    const notInArgs = keyAndAliases.every(val => args.indexOf(`--${val}`) === -1);\n                    if (notInArgs) {\n                        const startsByTwoDashes = (s) => /^--/.test(s);\n                        const isShortOption = (s) => /^[^0-9]$/.test(s);\n                        const dashes = !startsByTwoDashes(current) && isShortOption(key) ? '-' : '--';\n                        if (!zshShell) {\n                            completions.push(dashes + key);\n                        }\n                        else {\n                            const desc = descs[key] || '';\n                            completions.push(dashes + `${key.replace(/:/g, '\\\\:')}:${desc.replace('__yargsString__:', '')}`);\n                        }\n                    }\n                }\n                completeOptionKey(key);\n                if (negable && !!options.default[key])\n                    completeOptionKey(`no-${key}`);\n            });\n        }\n        done(completions);\n    };\n    // generate the completion script to add to your .bashrc.\n    self.generateCompletionScript = function generateCompletionScript($0, cmd) {\n        let script = zshShell ? templates.completionZshTemplate : templates.completionShTemplate;\n        const name = path.basename($0);\n        // add ./to applications not yet installed as bin.\n        if ($0.match(/\\.js$/))\n            $0 = `./${$0}`;\n        script = script.replace(/{{app_name}}/g, name);\n        script = script.replace(/{{completion_command}}/g, cmd);\n        return script.replace(/{{app_path}}/g, $0);\n    };\n    // register a function to perform your own custom\n    // completions., this function can be either\n    // synchrnous or asynchronous.\n    let completionFunction = null;\n    self.registerFunction = (fn) => {\n        completionFunction = fn;\n    };\n    return self;\n}\nexports.completion = completion;\nfunction isSyncCompletionFunction(completionFunction) {\n    return completionFunction.length < 3;\n}\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.completionZshTemplate = exports.completionShTemplate = void 0;\nexports.completionShTemplate = `###-begin-{{app_name}}-completions-###\n#\n# yargs command completion script\n#\n# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc\n#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.\n#\n_yargs_completions()\n{\n    local cur_word args type_list\n\n    cur_word=\"\\${COMP_WORDS[COMP_CWORD]}\"\n    args=(\"\\${COMP_WORDS[@]}\")\n\n    # ask yargs to generate completions.\n    type_list=$({{app_path}} --get-yargs-completions \"\\${args[@]}\")\n\n    COMPREPLY=( $(compgen -W \"\\${type_list}\" -- \\${cur_word}) )\n\n    # if no match was found, fall back to filename completion\n    if [ \\${#COMPREPLY[@]} -eq 0 ]; then\n      COMPREPLY=()\n    fi\n\n    return 0\n}\ncomplete -o default -F _yargs_completions {{app_name}}\n###-end-{{app_name}}-completions-###\n`;\nexports.completionZshTemplate = `###-begin-{{app_name}}-completions-###\n#\n# yargs command completion script\n#\n# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc\n#    or {{app_path}} {{completion_command}} >> ~/.zsh_profile on OSX.\n#\n_{{app_name}}_yargs_completions()\n{\n  local reply\n  local si=$IFS\n  IFS=$'\\n' reply=($(COMP_CWORD=\"$((CURRENT-1))\" COMP_LINE=\"$BUFFER\" COMP_POINT=\"$CURSOR\" {{app_path}} --get-yargs-completions \"\\${words[@]}\"))\n  IFS=$si\n  _describe 'values' reply\n}\ncompdef _{{app_name}}_yargs_completions {{app_name}}\n###-end-{{app_name}}-completions-###\n`;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validation = void 0;\nconst argsert_1 = require(\"./argsert\");\nconst common_types_1 = require(\"./common-types\");\nconst levenshtein_1 = require(\"./levenshtein\");\nconst obj_filter_1 = require(\"./obj-filter\");\nconst specialKeys = ['$0', '--', '_'];\n// validation-type-stuff, missing params,\n// bad implications, custom checks.\nfunction validation(yargs, usage, y18n) {\n    const __ = y18n.__;\n    const __n = y18n.__n;\n    const self = {};\n    // validate appropriate # of non-option\n    // arguments were provided, i.e., '_'.\n    self.nonOptionCount = function nonOptionCount(argv) {\n        const demandedCommands = yargs.getDemandedCommands();\n        // don't count currently executing commands\n        const _s = argv._.length - yargs.getContext().commands.length;\n        if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {\n            if (_s < demandedCommands._.min) {\n                if (demandedCommands._.minMsg !== undefined) {\n                    usage.fail(\n                    // replace $0 with observed, $1 with expected.\n                    demandedCommands._.minMsg\n                        ? demandedCommands._.minMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.min.toString())\n                        : null);\n                }\n                else {\n                    usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', _s, _s, demandedCommands._.min));\n                }\n            }\n            else if (_s > demandedCommands._.max) {\n                if (demandedCommands._.maxMsg !== undefined) {\n                    usage.fail(\n                    // replace $0 with observed, $1 with expected.\n                    demandedCommands._.maxMsg\n                        ? demandedCommands._.maxMsg.replace(/\\$0/g, _s.toString()).replace(/\\$1/, demandedCommands._.max.toString())\n                        : null);\n                }\n                else {\n                    usage.fail(__n('Too many non-option arguments: got %s, maximum of %s', 'Too many non-option arguments: got %s, maximum of %s', _s, _s, demandedCommands._.max));\n                }\n            }\n        }\n    };\n    // validate the appropriate # of <required>\n    // positional arguments were provided:\n    self.positionalCount = function positionalCount(required, observed) {\n        if (observed < required) {\n            usage.fail(__n('Not enough non-option arguments: got %s, need at least %s', 'Not enough non-option arguments: got %s, need at least %s', observed, observed, required));\n        }\n    };\n    // make sure all the required arguments are present.\n    self.requiredArguments = function requiredArguments(argv) {\n        const demandedOptions = yargs.getDemandedOptions();\n        let missing = null;\n        for (const key of Object.keys(demandedOptions)) {\n            if (!Object.prototype.hasOwnProperty.call(argv, key) || typeof argv[key] === 'undefined') {\n                missing = missing || {};\n                missing[key] = demandedOptions[key];\n            }\n        }\n        if (missing) {\n            const customMsgs = [];\n            for (const key of Object.keys(missing)) {\n                const msg = missing[key];\n                if (msg && customMsgs.indexOf(msg) < 0) {\n                    customMsgs.push(msg);\n                }\n            }\n            const customMsg = customMsgs.length ? `\\n${customMsgs.join('\\n')}` : '';\n            usage.fail(__n('Missing required argument: %s', 'Missing required arguments: %s', Object.keys(missing).length, Object.keys(missing).join(', ') + customMsg));\n        }\n    };\n    // check for unknown arguments (strict-mode).\n    self.unknownArguments = function unknownArguments(argv, aliases, positionalMap, isDefaultCommand) {\n        const commandKeys = yargs.getCommandInstance().getCommands();\n        const unknown = [];\n        const currentContext = yargs.getContext();\n        Object.keys(argv).forEach((key) => {\n            if (specialKeys.indexOf(key) === -1 &&\n                !Object.prototype.hasOwnProperty.call(positionalMap, key) &&\n                !Object.prototype.hasOwnProperty.call(yargs._getParseContext(), key) &&\n                !self.isValidAndSomeAliasIsNotNew(key, aliases)) {\n                unknown.push(key);\n            }\n        });\n        if ((currentContext.commands.length > 0) || (commandKeys.length > 0) || isDefaultCommand) {\n            argv._.slice(currentContext.commands.length).forEach((key) => {\n                if (commandKeys.indexOf(key) === -1) {\n                    unknown.push(key);\n                }\n            });\n        }\n        if (unknown.length > 0) {\n            usage.fail(__n('Unknown argument: %s', 'Unknown arguments: %s', unknown.length, unknown.join(', ')));\n        }\n    };\n    self.unknownCommands = function unknownCommands(argv) {\n        const commandKeys = yargs.getCommandInstance().getCommands();\n        const unknown = [];\n        const currentContext = yargs.getContext();\n        if ((currentContext.commands.length > 0) || (commandKeys.length > 0)) {\n            argv._.slice(currentContext.commands.length).forEach((key) => {\n                if (commandKeys.indexOf(key) === -1) {\n                    unknown.push(key);\n                }\n            });\n        }\n        if (unknown.length > 0) {\n            usage.fail(__n('Unknown command: %s', 'Unknown commands: %s', unknown.length, unknown.join(', ')));\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    // check for a key that is not an alias, or for which every alias is new,\n    // implying that it was invented by the parser, e.g., during camelization\n    self.isValidAndSomeAliasIsNotNew = function isValidAndSomeAliasIsNotNew(key, aliases) {\n        if (!Object.prototype.hasOwnProperty.call(aliases, key)) {\n            return false;\n        }\n        const newAliases = yargs.parsed.newAliases;\n        for (const a of [key, ...aliases[key]]) {\n            if (!Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]) {\n                return true;\n            }\n        }\n        return false;\n    };\n    // validate arguments limited to enumerated choices\n    self.limitedChoices = function limitedChoices(argv) {\n        const options = yargs.getOptions();\n        const invalid = {};\n        if (!Object.keys(options.choices).length)\n            return;\n        Object.keys(argv).forEach((key) => {\n            if (specialKeys.indexOf(key) === -1 &&\n                Object.prototype.hasOwnProperty.call(options.choices, key)) {\n                [].concat(argv[key]).forEach((value) => {\n                    // TODO case-insensitive configurability\n                    if (options.choices[key].indexOf(value) === -1 &&\n                        value !== undefined) {\n                        invalid[key] = (invalid[key] || []).concat(value);\n                    }\n                });\n            }\n        });\n        const invalidKeys = Object.keys(invalid);\n        if (!invalidKeys.length)\n            return;\n        let msg = __('Invalid values:');\n        invalidKeys.forEach((key) => {\n            msg += `\\n  ${__('Argument: %s, Given: %s, Choices: %s', key, usage.stringifiedValues(invalid[key]), usage.stringifiedValues(options.choices[key]))}`;\n        });\n        usage.fail(msg);\n    };\n    // custom checks, added using the `check` option on yargs.\n    let checks = [];\n    self.check = function check(f, global) {\n        checks.push({\n            func: f,\n            global\n        });\n    };\n    self.customChecks = function customChecks(argv, aliases) {\n        for (let i = 0, f; (f = checks[i]) !== undefined; i++) {\n            const func = f.func;\n            let result = null;\n            try {\n                result = func(argv, aliases);\n            }\n            catch (err) {\n                usage.fail(err.message ? err.message : err, err);\n                continue;\n            }\n            if (!result) {\n                usage.fail(__('Argument check failed: %s', func.toString()));\n            }\n            else if (typeof result === 'string' || result instanceof Error) {\n                usage.fail(result.toString(), result);\n            }\n        }\n    };\n    // check implications, argument foo implies => argument bar.\n    let implied = {};\n    self.implies = function implies(key, value) {\n        argsert_1.argsert('<string|object> [array|number|string]', [key, value], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach((k) => {\n                self.implies(k, key[k]);\n            });\n        }\n        else {\n            yargs.global(key);\n            if (!implied[key]) {\n                implied[key] = [];\n            }\n            if (Array.isArray(value)) {\n                value.forEach((i) => self.implies(key, i));\n            }\n            else {\n                common_types_1.assertNotStrictEqual(value, undefined);\n                implied[key].push(value);\n            }\n        }\n    };\n    self.getImplied = function getImplied() {\n        return implied;\n    };\n    function keyExists(argv, val) {\n        // convert string '1' to number 1\n        const num = Number(val);\n        val = isNaN(num) ? val : num;\n        if (typeof val === 'number') {\n            // check length of argv._\n            val = argv._.length >= val;\n        }\n        else if (val.match(/^--no-.+/)) {\n            // check if key/value doesn't exist\n            val = val.match(/^--no-(.+)/)[1];\n            val = !argv[val];\n        }\n        else {\n            // check if key/value exists\n            val = argv[val];\n        }\n        return val;\n    }\n    self.implications = function implications(argv) {\n        const implyFail = [];\n        Object.keys(implied).forEach((key) => {\n            const origKey = key;\n            (implied[key] || []).forEach((value) => {\n                let key = origKey;\n                const origValue = value;\n                key = keyExists(argv, key);\n                value = keyExists(argv, value);\n                if (key && !value) {\n                    implyFail.push(` ${origKey} -> ${origValue}`);\n                }\n            });\n        });\n        if (implyFail.length) {\n            let msg = `${__('Implications failed:')}\\n`;\n            implyFail.forEach((value) => {\n                msg += (value);\n            });\n            usage.fail(msg);\n        }\n    };\n    let conflicting = {};\n    self.conflicts = function conflicts(key, value) {\n        argsert_1.argsert('<string|object> [array|string]', [key, value], arguments.length);\n        if (typeof key === 'object') {\n            Object.keys(key).forEach((k) => {\n                self.conflicts(k, key[k]);\n            });\n        }\n        else {\n            yargs.global(key);\n            if (!conflicting[key]) {\n                conflicting[key] = [];\n            }\n            if (Array.isArray(value)) {\n                value.forEach((i) => self.conflicts(key, i));\n            }\n            else {\n                conflicting[key].push(value);\n            }\n        }\n    };\n    self.getConflicting = () => conflicting;\n    self.conflicting = function conflictingFn(argv) {\n        Object.keys(argv).forEach((key) => {\n            if (conflicting[key]) {\n                conflicting[key].forEach((value) => {\n                    // we default keys to 'undefined' that have been configured, we should not\n                    // apply conflicting check unless they are a value other than 'undefined'.\n                    if (value && argv[key] !== undefined && argv[value] !== undefined) {\n                        usage.fail(__('Arguments %s and %s are mutually exclusive', key, value));\n                    }\n                });\n            }\n        });\n    };\n    self.recommendCommands = function recommendCommands(cmd, potentialCommands) {\n        const threshold = 3; // if it takes more than three edits, let's move on.\n        potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);\n        let recommended = null;\n        let bestDistance = Infinity;\n        for (let i = 0, candidate; (candidate = potentialCommands[i]) !== undefined; i++) {\n            const d = levenshtein_1.levenshtein(cmd, candidate);\n            if (d <= threshold && d < bestDistance) {\n                bestDistance = d;\n                recommended = candidate;\n            }\n        }\n        if (recommended)\n            usage.fail(__('Did you mean %s?', recommended));\n    };\n    self.reset = function reset(localLookup) {\n        implied = obj_filter_1.objFilter(implied, k => !localLookup[k]);\n        conflicting = obj_filter_1.objFilter(conflicting, k => !localLookup[k]);\n        checks = checks.filter(c => c.global);\n        return self;\n    };\n    const frozens = [];\n    self.freeze = function freeze() {\n        frozens.push({\n            implied,\n            checks,\n            conflicting\n        });\n    };\n    self.unfreeze = function unfreeze() {\n        const frozen = frozens.pop();\n        common_types_1.assertNotStrictEqual(frozen, undefined);\n        ({\n            implied,\n            checks,\n            conflicting\n        } = frozen);\n    };\n    return self;\n}\nexports.validation = validation;\n","\n/*\nCopyright (c) 2011 Andrei Mackenzie\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.levenshtein = void 0;\n// levenshtein distance algorithm, pulled from Andrei Mackenzie's MIT licensed.\n// gist, which can be found here: https://gist.github.com/andrei-m/982927\n// Compute the edit distance between the two given strings\nfunction levenshtein(a, b) {\n    if (a.length === 0)\n        return b.length;\n    if (b.length === 0)\n        return a.length;\n    const matrix = [];\n    // increment along the first column of each row\n    let i;\n    for (i = 0; i <= b.length; i++) {\n        matrix[i] = [i];\n    }\n    // increment each column in the first row\n    let j;\n    for (j = 0; j <= a.length; j++) {\n        matrix[0][j] = j;\n    }\n    // Fill in the rest of the matrix\n    for (i = 1; i <= b.length; i++) {\n        for (j = 1; j <= a.length; j++) {\n            if (b.charAt(i - 1) === a.charAt(j - 1)) {\n                matrix[i][j] = matrix[i - 1][j - 1];\n            }\n            else {\n                matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution\n                Math.min(matrix[i][j - 1] + 1, // insertion\n                matrix[i - 1][j] + 1)); // deletion\n            }\n        }\n    }\n    return matrix[b.length][a.length];\n}\nexports.levenshtein = levenshtein;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.applyExtends = void 0;\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst yerror_1 = require(\"./yerror\");\nlet previouslyVisitedConfigs = [];\nfunction checkForCircularExtends(cfgPath) {\n    if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {\n        throw new yerror_1.YError(`Circular extended configurations: '${cfgPath}'.`);\n    }\n}\nfunction getPathToDefaultConfig(cwd, pathToExtend) {\n    return path.resolve(cwd, pathToExtend);\n}\nfunction mergeDeep(config1, config2) {\n    const target = {};\n    function isObject(obj) {\n        return obj && typeof obj === 'object' && !Array.isArray(obj);\n    }\n    Object.assign(target, config1);\n    for (const key of Object.keys(config2)) {\n        if (isObject(config2[key]) && isObject(target[key])) {\n            target[key] = mergeDeep(config1[key], config2[key]);\n        }\n        else {\n            target[key] = config2[key];\n        }\n    }\n    return target;\n}\nfunction applyExtends(config, cwd, mergeExtends = false) {\n    let defaultConfig = {};\n    if (Object.prototype.hasOwnProperty.call(config, 'extends')) {\n        if (typeof config.extends !== 'string')\n            return defaultConfig;\n        const isPath = /\\.json|\\..*rc$/.test(config.extends);\n        let pathToDefault = null;\n        if (!isPath) {\n            try {\n                pathToDefault = require.resolve(config.extends);\n            }\n            catch (err) {\n                // most likely this simply isn't a module.\n            }\n        }\n        else {\n            pathToDefault = getPathToDefaultConfig(cwd, config.extends);\n        }\n        // maybe the module uses key for some other reason,\n        // err on side of caution.\n        if (!pathToDefault && !isPath)\n            return config;\n        if (!pathToDefault)\n            throw new yerror_1.YError(`Unable to find extended config '${config.extends}' in '${cwd}'.`);\n        checkForCircularExtends(pathToDefault);\n        previouslyVisitedConfigs.push(pathToDefault);\n        defaultConfig = isPath ? JSON.parse(fs.readFileSync(pathToDefault, 'utf8')) : require(config.extends);\n        delete config.extends;\n        defaultConfig = applyExtends(defaultConfig, path.dirname(pathToDefault), mergeExtends);\n    }\n    previouslyVisitedConfigs = [];\n    return mergeExtends ? mergeDeep(defaultConfig, config) : Object.assign({}, defaultConfig, config);\n}\nexports.applyExtends = applyExtends;\n","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getProcessArgvBin = exports.getProcessArgvWithoutBin = void 0;\nfunction getProcessArgvBinIndex() {\n    // The binary name is the first command line argument for:\n    // - bundled Electron apps: bin argv1 argv2 ... argvn\n    if (isBundledElectronApp())\n        return 0;\n    // or the second one (default) for:\n    // - standard node apps: node bin.js argv1 argv2 ... argvn\n    // - unbundled Electron apps: electron bin.js argv1 arg2 ... argvn\n    return 1;\n}\nfunction isBundledElectronApp() {\n    // process.defaultApp is either set by electron in an electron unbundled app, or undefined\n    // see https://github.com/electron/electron/blob/master/docs/api/process.md#processdefaultapp-readonly\n    return isElectronApp() && !process.defaultApp;\n}\nfunction isElectronApp() {\n    // process.versions.electron is either set by electron, or undefined\n    // see https://github.com/electron/electron/blob/master/docs/api/process.md#processversionselectron-readonly\n    return !!process.versions.electron;\n}\nfunction getProcessArgvWithoutBin() {\n    return process.argv.slice(getProcessArgvBinIndex() + 1);\n}\nexports.getProcessArgvWithoutBin = getProcessArgvWithoutBin;\nfunction getProcessArgvBin() {\n    return process.argv[getProcessArgvBinIndex()];\n}\nexports.getProcessArgvBin = getProcessArgvBin;\n"]}